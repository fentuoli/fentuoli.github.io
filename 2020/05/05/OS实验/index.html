<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fentuoli.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本实验是操作系统课程的要求实验，大致为实现一个FAT文件系统，具体要求和完整代码请参见我的github地址： https:&#x2F;&#x2F;github.com&#x2F;fentuoli&#x2F;FAT-file-system  一、实验内容及要求​       熟悉FAT16的存储结构，利用FUSE实现一个只读的FAT文件系统 。 二、实验准备工作1.熟悉使用FUSE 配置FUSE环境">
<meta property="og:type" content="article">
<meta property="og:title" content="FAT文件系统的实现">
<meta property="og:url" content="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="BoRe">
<meta property="og:description" content="本实验是操作系统课程的要求实验，大致为实现一个FAT文件系统，具体要求和完整代码请参见我的github地址： https:&#x2F;&#x2F;github.com&#x2F;fentuoli&#x2F;FAT-file-system  一、实验内容及要求​       熟悉FAT16的存储结构，利用FUSE实现一个只读的FAT文件系统 。 二、实验准备工作1.熟悉使用FUSE 配置FUSE环境">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/10.PNG">
<meta property="og:image" content="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/11.PNG">
<meta property="og:image" content="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/12.PNG">
<meta property="og:image" content="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/13.PNG">
<meta property="og:image" content="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/14.PNG">
<meta property="og:image" content="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/15.PNG">
<meta property="og:image" content="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/16.PNG">
<meta property="article:published_time" content="2020-05-05T06:07:11.000Z">
<meta property="article:modified_time" content="2021-03-15T10:06:28.380Z">
<meta property="article:author" content="般若">
<meta property="article:tag" content="Lessons">
<meta property="article:tag" content="FAT">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/10.PNG">

<link rel="canonical" href="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>FAT文件系统的实现 | BoRe</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BoRe</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fentuoli.github.io/2020/05/05/OS%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="般若">
      <meta itemprop="description" content="般若的blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoRe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          FAT文件系统的实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-05 14:07:11" itemprop="dateCreated datePublished" datetime="2020-05-05T14:07:11+08:00">2020-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-15 18:06:28" itemprop="dateModified" datetime="2021-03-15T18:06:28+08:00">2021-03-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">专业课程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本实验是操作系统课程的要求实验，大致为实现一个FAT文件系统，具体要求和完整代码请参见我的github地址： <a href="https://github.com/fentuoli/FAT-file-system" target="_blank" rel="noopener">https://github.com/fentuoli/FAT-file-system</a> </p>
<h2 id="一、实验内容及要求"><a href="#一、实验内容及要求" class="headerlink" title="一、实验内容及要求"></a>一、实验内容及要求</h2><p>​       熟悉FAT16的存储结构，利用FUSE实现一个只读的FAT文件系统 。</p>
<h2 id="二、实验准备工作"><a href="#二、实验准备工作" class="headerlink" title="二、实验准备工作"></a>二、实验准备工作</h2><h3 id="1-熟悉使用FUSE"><a href="#1-熟悉使用FUSE" class="headerlink" title="1.熟悉使用FUSE"></a>1.熟悉使用FUSE</h3><ul>
<li>配置FUSE环境</li>
</ul>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -O libfuse-2.9.5.zip https://codeload.github.com/libfuse/libfuse/zip/fuse_2_9_5 unzip libfuse-2.9.5.zip </span><br><span class="line">cd libfuse-fuse_2_9_5/ </span><br><span class="line">./makeconf.sh </span><br><span class="line">./configure --prefix=/usr </span><br><span class="line">make -j4 </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<ul>
<li><p>编译出错处理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libtool </span><br><span class="line">sudo apt install autoconf</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试FUSE</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd example </span><br><span class="line">mkdir fuse_test_dir </span><br><span class="line">./fusexmp -d fuse_test_dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>用Ctrl+C结束程序。</p>
</li>
</ul>
<h3 id="2-FAT文件系统"><a href="#2-FAT文件系统" class="headerlink" title="2.FAT文件系统"></a>2.FAT文件系统</h3><ol>
<li><p>FAT格式磁盘镜像的制作过程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=fat-disk.img bs=1M count=100</span><br><span class="line">mkfs.vfat -F 16 fat-disk.img</span><br><span class="line">mkdir mdir </span><br><span class="line">mount fat-disk.img mdir</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/05/OS%E5%AE%9E%E9%AA%8C/10.PNG" alt="10"></p>
</li>
<li><p>FAT16的存储结构</p>
<ul>
<li><p>FAT16文件系统的基本结构依次为：DBR扇区、FAT表1、FAT表2、根目录和数据区，FAT16格式的磁盘的组织 方式如下图所示：</p>
</li>
<li><p>DBR扇区：由于lab4.pdf上所给的DBR扇区内容表格不够完整，所以我又自行检索了一个更加完整的表格</p>
<p><img src="/2020/05/05/OS%E5%AE%9E%E9%AA%8C/11.PNG" alt="11"></p>
<p><img src="/2020/05/05/OS%E5%AE%9E%E9%AA%8C/12.PNG" alt="12"></p>
<p><img src="/2020/05/05/OS%E5%AE%9E%E9%AA%8C/13.PNG" alt="13"></p>
<ul>
<li>我们可以根据上述的BPB的字段计算FAT系统的各个部分的偏移地址和大小。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FatStartSector = BPB_ResvSecCnt;</span><br><span class="line">FatSectors = BPB_FATSz * BPB_NumFATs;</span><br></pre></td></tr></table></figure>

<ul>
<li>根目录区的偏移地址和大小可以计算如下，计算根目录扇区数量时乘以的32是指目录中的一条记录长度为32个字节。 加上BPB_BytsPerSec再减去1是为了做除法运算时向上取整的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RootDirStartSector = FatStartSector + FatSectors;</span><br><span class="line">RootDirSectors = (32 * BPB_RootEntCnt + BPB_BytsPerSec - 1) / BPB_BytsPerSec;</span><br></pre></td></tr></table></figure>

<ul>
<li>根目录区之后就是数据区，用于记录实际的文件和目录内容的区域。我们可以通过如下的语句计算数据区的偏移地址和大小。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataStartSector = RootDirStartSector + RootDirSectors;</span><br><span class="line">DataSectors = BPB_TotSec - DataStartSector;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FAT表：</p>
<p><img src="/2020/05/05/OS%E5%AE%9E%E9%AA%8C/14.PNG" alt="14"></p>
</li>
<li><p>根目录：：FAT文件系统的一个重要思想是把目录当作一个特殊文件来处理，在FAT16中，虽然根目录地位并不等 同于普通的目录，但其组织形式和普通的目录并没有不同。不管目录文件所占空间为多少簇，系统都会以32个 字节为单位进行目录文件所占簇的分配。每个32字节目录项表示的具体含义如下：</p>
</li>
<li><p>FAT表与文件定位：</p>
<p>​        FAT16文件系统从根目录所占的32个扇区之后的第一个扇区开始以簇为单位进行数据的处 理，这之前仍以扇区为单位。对于根目录之后的第一个簇，系统并不编号为0号簇或1号簇，而是编号为2号簇， 也就是说数据区顺序上的第1个簇也是编号上的2号簇。 </p>
<p>​         假设一个文件，其首簇号是2，则查看FAT的相对偏移0x4~0x5的内容，此处为0xFFFF，表示存储在2号簇上的文 件是个小文件，只占用1个簇便结束了。 假设另一个文件的首簇号是8，则查看FAT的相对偏移0x10-0x11的内容，为0x0009，就是说该文件继8号簇后 的内容会存放在9号簇中；继续查看9号簇的FAT表项内容是0x000A，该文件继9簇后的内容会存放在10号簇 中，继续这个过程，会发现文件在11号簇结束。 </p>
<p><img src="/2020/05/05/OS%E5%AE%9E%E9%AA%8C/15.PNG" alt="15"></p>
</li>
</ul>
</li>
</ol>
<h2 id="三、实验操作过程"><a href="#三、实验操作过程" class="headerlink" title="三、实验操作过程"></a>三、实验操作过程</h2><h3 id="1-TODO-1"><a href="#1-TODO-1" class="headerlink" title="1.TODO 1"></a>1.TODO 1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * 将输入路径按“/”分割成多个字符串，并按照FAT文件名格式转换字符串</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Hint1:假设pathInput为“/dir1/dir2/file.txt”，则将其分割成“dir1”，“dir2”，“file.txt”，</span></span><br><span class="line"><span class="comment"> *      每个字符串转换成长度为11的FAT格式的文件名，如“file.txt”转换成“FILE    TXT”，</span></span><br><span class="line"><span class="comment"> *      返回转换后的字符串数组，并将*pathDepth_ret设置为3</span></span><br><span class="line"><span class="comment"> * Hint2:可能会出现过长的字符串输入，如“/.Trash-1000”，需要自行截断字符串</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">path_split</span><span class="params">(<span class="keyword">char</span> *pathInput, <span class="keyword">int</span> *pathDepth_ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pathDepth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> **pathchange = <span class="built_in">malloc</span>(pathDepth * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    <span class="keyword">int</span> len,i,j,k,pathnum=<span class="number">0</span>,m=<span class="number">0</span>,n=<span class="number">0</span>;</span><br><span class="line">    len=<span class="built_in">strlen</span>(pathInput);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(pathInput[i]!=<span class="string">'/'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">            pathnum++;</span><br><span class="line">    &#125;</span><br><span class="line">    *pathDepth_ret=pathnum;</span><br><span class="line">    pathDepth=pathnum;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;pathnum;i++)</span><br><span class="line">       pathchange[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(MAX_SHORT_NAME_LEN *<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//pathchange中存储最终转换为FAT格式的路径</span></span><br><span class="line">    <span class="keyword">char</span> pathdiv[pathnum][<span class="number">30</span>],a[pathnum][<span class="number">30</span>],b[pathnum][<span class="number">30</span>];<span class="comment">//pathdiv中存储按'/'进行分割的路径</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(pathInput[i]!=<span class="string">'/'</span>)&#123;</span><br><span class="line">	    pathdiv[m][n]=pathInput[i];</span><br><span class="line">	    n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	     pathdiv[m][n]=<span class="string">'\0'</span>;</span><br><span class="line">	     m++;</span><br><span class="line">	     n=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   pathdiv[m][n]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;pathnum;i++)&#123;</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(pathdiv[i]);j++)&#123;</span><br><span class="line">		b[i][<span class="number">0</span>]=<span class="string">'\0'</span>;</span><br><span class="line">	    <span class="keyword">if</span>(pathdiv[i][j]!=<span class="string">'.'</span>)</span><br><span class="line">	        a[i][j]=pathdiv[i][j];	<span class="comment">//a中存储'.'之前的字符串    </span></span><br><span class="line">	    <span class="keyword">else</span>&#123;</span><br><span class="line">		a[i][j]=<span class="string">'\0'</span>;</span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">for</span>(k=j;k&lt;<span class="built_in">strlen</span>(pathdiv[i]);k++)&#123;</span><br><span class="line">		  b[i][k-j]=pathdiv[i][k];</span><br><span class="line">		&#125;</span><br><span class="line">		b[i][k-j]=<span class="string">'\0'</span>;<span class="comment">//b中存储'.'之后的字符串</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">        a[i][j]=<span class="string">'\0'</span>;	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(a[i])&lt;<span class="number">8</span>)&#123;</span><br><span class="line">	   <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(a[i]);j++)&#123;	   </span><br><span class="line">	      <span class="keyword">if</span>(a[i][j]&gt;=<span class="string">'a'</span> &amp;&amp; a[i][j]&lt;=<span class="string">'z'</span>)</span><br><span class="line">		  pathchange[i][j]=<span class="built_in">toupper</span>(a[i][j]);<span class="comment">//toupper函数将小写字母转换为大写字母</span></span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		  pathchange[i][j]=a[i][j];<span class="comment">//非小写字母的字符保存不变</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(k=j;k&lt;<span class="number">8</span>;k++)</span><br><span class="line">	      pathchange[i][k]=<span class="string">' '</span>;<span class="comment">//补空格</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;	   </span><br><span class="line">	      <span class="keyword">if</span>(a[i][j]&gt;=<span class="string">'a'</span> &amp;&amp; a[i][j]&lt;=<span class="string">'z'</span>)</span><br><span class="line">		  pathchange[i][j]=<span class="built_in">toupper</span>(a[i][j]);</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		  pathchange[i][j]=a[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(b[i])&lt;<span class="number">3</span>)&#123;</span><br><span class="line">	   <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(b[i]);j++)&#123;	   </span><br><span class="line">	      <span class="keyword">if</span>(b[i][j]&gt;=<span class="string">'a'</span> &amp;&amp; b[i][j]&lt;=<span class="string">'z'</span>)</span><br><span class="line">		  pathchange[i][<span class="number">8</span>+j]=<span class="built_in">toupper</span>(b[i][j]);</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		  pathchange[i][<span class="number">8</span>+j]=b[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(k=j;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">	      pathchange[i][k+<span class="number">8</span>]=<span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;	   </span><br><span class="line">	      <span class="keyword">if</span>(b[i][j]&gt;=<span class="string">'a'</span> &amp;&amp; b[i][j]&lt;=<span class="string">'z'</span>)</span><br><span class="line">		  pathchange[i][<span class="number">8</span>+j]=<span class="built_in">toupper</span>(b[i][j]);</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		  pathchange[i][<span class="number">8</span>+j]=b[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;pathnum;i++)&#123;</span><br><span class="line">	pathchange[i][<span class="number">11</span>]=<span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pathchange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：**path_split函数的功能就是将输入路径按’’/‘’进行分割，并将每一级目录按’’.’’进行划分，’’.’’之前的字符串占8位，’’.’’之后的字符串占三位，多余的截断，不足的用空格补全。字符串中所有的小写字母转换为其大写形式，其余字符不变。</p>
<h3 id="2-TODO-2"><a href="#2-TODO-2" class="headerlink" title="2.TODO 2"></a>2.TODO 2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * 将FAT文件名格式解码成原始的文件名</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Hint:假设path是“FILE    TXT”，则返回"file.txt"</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function">BYTE *<span class="title">path_decode</span><span class="params">(BYTE *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BYTE *path_pre = <span class="built_in">malloc</span>(MAX_SHORT_NAME_LEN * <span class="keyword">sizeof</span>(BYTE));</span><br><span class="line">  <span class="keyword">int</span> i,j,k,len;</span><br><span class="line">  len=<span class="built_in">strlen</span>(path);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;<span class="comment">//对前8位字符进行操作</span></span><br><span class="line">     <span class="keyword">if</span>(path[i]&gt;=<span class="string">'A'</span> &amp;&amp; path[i]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">        path_pre[i]=<span class="built_in">tolower</span>(path[i]);</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(path[i]!=<span class="string">' '</span>)</span><br><span class="line">	   path_pre[i]=path[i];</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	   <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  j=i; </span><br><span class="line">     <span class="keyword">if</span>(path[<span class="number">8</span>]==<span class="string">' '</span>)&#123;</span><br><span class="line">	path_pre[j]=<span class="string">'\0'</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">	path_pre[j]=<span class="string">'.'</span>;</span><br><span class="line">	j++;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">8</span>;i&lt;<span class="number">11</span>;i++)&#123;<span class="comment">//对后3位字符进行操作</span></span><br><span class="line">        <span class="keyword">if</span>(path[i]&gt;=<span class="string">'A'</span> &amp;&amp; path[i]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">           path_pre[j++]=<span class="built_in">tolower</span>(path[i]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">	   <span class="keyword">if</span>(path[i]!=<span class="string">' '</span>)</span><br><span class="line">	      path_pre[j++]=path[i];</span><br><span class="line">	   <span class="keyword">else</span>&#123;</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   path_pre[j]=<span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">return</span> path_pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该函数就是**path_split的反向操作，将输入路径的前8位转换成’.’之前的字符串，后三位转换成’.’之后的字符串，将空格去掉，小写字母变大写字母，其余字母保持不变。</p>
<h3 id="3-TODO-3"><a href="#3-TODO-3" class="headerlink" title="3.TODO 3"></a>3.TODO 3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FAT16 *<span class="title">pre_init_fat16</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  FILE *fd;</span><br><span class="line">  FAT16 *fat16_ins;</span><br><span class="line"></span><br><span class="line">  fd = fopen(FAT_FILE_NAME, <span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Missing FAT16 image file!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fat16_ins = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FAT16));</span><br><span class="line">  fat16_ins-&gt;fd = fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** <span class="doctag">TODO:</span> </span></span><br><span class="line"><span class="comment">   * 初始化fat16_ins的其余成员变量</span></span><br><span class="line"><span class="comment">   * Hint: root directory的大小与Bpb.BPB_RootEntCnt有关，并且是扇区对齐的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"></span><br><span class="line">  BYTE <span class="built_in">buffer</span>[BYTES_PER_SECTOR];</span><br><span class="line">  fread(fat16_ins-&gt;Bpb.BS_jmpBoot,<span class="keyword">sizeof</span>(BYTE),<span class="number">0x200</span>,fd);</span><br><span class="line">  fat16_ins-&gt;FirstRootDirSecNum=fat16_ins-&gt;Bpb.BPB_RsvdSecCnt+fat16_ins-&gt;Bpb.BPB_FATSz16*fat16_ins-&gt;Bpb.BPB_NumFATS;</span><br><span class="line">  fat16_ins-&gt;FirstDataSector=fat16_ins-&gt;FirstRootDirSecNum + BYTES_PER_DIR*fat16_ins-&gt;Bpb.BPB_RootEntCnt/fat16_ins-&gt;Bpb.BPB_BytsPerSec;</span><br><span class="line">  <span class="keyword">return</span> fat16_ins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该函数的功能是初始化fat16_ins的成员变量，对FAT16的定义在fat16.h文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE *fd;</span><br><span class="line">  DWORD FirstRootDirSecNum;</span><br><span class="line">  DWORD FirstDataSector;</span><br><span class="line">  BPB_BS Bpb;</span><br><span class="line">&#125; FAT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  BYTE BS_jmpBoot[<span class="number">3</span>];</span><br><span class="line">  BYTE BS_OEMName[<span class="number">8</span>];</span><br><span class="line">  WORD BPB_BytsPerSec;</span><br><span class="line">  BYTE BPB_SecPerClus;</span><br><span class="line">  WORD BPB_RsvdSecCnt;</span><br><span class="line">  BYTE BPB_NumFATS;</span><br><span class="line">  WORD BPB_RootEntCnt;</span><br><span class="line">  WORD BPB_TotSec16;</span><br><span class="line">  BYTE BPB_Media;</span><br><span class="line">  WORD BPB_FATSz16;</span><br><span class="line">  WORD BPB_SecPerTrk;</span><br><span class="line">  WORD BPB_NumHeads;</span><br><span class="line">  DWORD BPB_HiddSec;</span><br><span class="line">  DWORD BPB_TotSec32;</span><br><span class="line">  BYTE BS_DrvNum;</span><br><span class="line">  BYTE BS_Reserved1;</span><br><span class="line">  BYTE BS_BootSig;</span><br><span class="line">  DWORD BS_VollID;</span><br><span class="line">  BYTE BS_VollLab[<span class="number">11</span>];</span><br><span class="line">  BYTE BS_FilSysType[<span class="number">8</span>];</span><br><span class="line">  BYTE Reserved2[<span class="number">448</span>];</span><br><span class="line">  WORD Signature_word;</span><br><span class="line">&#125; __attribute__ ((packed)) BPB_BS;</span><br></pre></td></tr></table></figure>

<p>其中以BPB和BS为前缀的变量均存储在DBR扇区中，且这些变量按其偏移大小依次排列，故可以直接通过首地址进行填充：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread(fat16_ins-&gt;Bpb.BS_jmpBoot,<span class="keyword">sizeof</span>(BYTE),<span class="number">0x200</span>,fd);</span><br></pre></td></tr></table></figure>

<p>至于FirstRootDirSecNum和FirstDataSector两个变量可以通过计算得出，具体计算方法的说明参见上文FAT16的存储结构中的说明。</p>
<h3 id="4-TODO-4"><a href="#4-TODO-4" class="headerlink" title="4.TODO 4"></a>4.TODO 4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * 返回簇号为ClusterN对应的FAT表项</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">WORD <span class="title">fat_entry_by_cluster</span><span class="params">(FAT16 *fat16_ins, WORD ClusterN)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BYTE sector_buffer[BYTES_PER_SECTOR];</span><br><span class="line">    <span class="keyword">int</span> clusternum=fat16_ins-&gt;Bpb.BPB_RsvdSecCnt+ClusterN*<span class="number">2</span>/BYTES_PER_SECTOR;<span class="comment">//计算簇号对应扇区</span></span><br><span class="line">    <span class="keyword">int</span> offset=ClusterN*<span class="number">2</span>%BYTES_PER_SECTOR;<span class="comment">//计算在该扇区内的偏移量</span></span><br><span class="line">    WORD FAT_content;</span><br><span class="line">    sector_read(fat16_ins-&gt;fd,clusternum,sector_buffer);<span class="comment">//读取该扇区内容</span></span><br><span class="line">    FAT_content=(WORD)sector_buffer[offset+<span class="number">1</span>]*<span class="number">0x0100</span> + (WORD)sector_buffer[offset];<span class="comment">//读取内容</span></span><br><span class="line">    <span class="keyword">return</span> FAT_content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>由于一个文件与其存储在FAT1中的位置是*2的关系，故在计算簇号对应的扇区号与在该扇区中的偏移量的时候需要将簇号*2。</li>
<li>由于FAT文件系统的存储方式为小端存储，故在读取内容时，读取高地址处的内容作为高位，低地址处的作为低位。</li>
</ul>
<h3 id="5-TODO-5"><a href="#5-TODO-5" class="headerlink" title="5.TODO 5"></a>5.TODO 5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从root directory开始，查找path对应的文件或目录，找到返回0，没找到返回1，并将Dir填充为查找到的对应目录项</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Hint: 假设path是“/dir1/dir2/file”，则先在root directory中查找名为dir1的目录，</span></span><br><span class="line"><span class="comment"> *       然后在dir1中查找名为dir2的目录，最后在dir2中查找名为file的文件，找到则返回0，并且将file的目录项数据写入到参数Dir对应的DIR_ENTRY中</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(FAT16 *fat16_ins, DIR_ENTRY *Dir, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pathDepth;</span><br><span class="line">    <span class="keyword">char</span> **paths = path_split((<span class="keyword">char</span> *)path, &amp;pathDepth);</span><br><span class="line">    BYTE *p;</span><br><span class="line">    <span class="keyword">int</span> ii,i, j,k,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> RootDirCnt = <span class="number">1</span>;   </span><br><span class="line">    BYTE <span class="built_in">buffer</span>[BYTES_PER_SECTOR]; </span><br><span class="line">    <span class="keyword">int</span> RootDirSectors = (<span class="number">32</span>*fat16_ins-&gt;Bpb.BPB_RootEntCnt+fat16_ins-&gt;Bpb.BPB_BytsPerSec<span class="number">-1</span>)/fat16_ins-&gt;Bpb.BPB_BytsPerSec;<span class="comment">//RootDirSectors为根目录中的扇区数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment">   * 查找名字为paths[0]的目录项，</span></span><br><span class="line"><span class="comment">   * 如果找到目录，则根据pathDepth判断是否需要调用find_subdir继续查找，</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * !!注意root directory可能包含多个扇区</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ii=<span class="number">0</span>;ii&lt;RootDirSectors;ii++)&#123;</span><br><span class="line">  sector_read(fat16_ins-&gt;fd, fat16_ins-&gt;FirstRootDirSecNum+ii, <span class="built_in">buffer</span>);<span class="comment">//读入每个扇区的内容</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fat16_ins-                   &gt;Bpb.BPB_BytsPerSec/RootDirSectors; i++)&#123; <span class="comment">//求出每个扇区中表项的个数 </span></span><br><span class="line">    p=&amp;<span class="built_in">buffer</span>[i*BYTES_PER_DIR];<span class="comment">//读入Dir</span></span><br><span class="line">    *Dir=*(DIR_ENTRY*)p;</span><br><span class="line">    <span class="keyword">if</span>(Dir-&gt;DIR_Name[<span class="number">0</span>]==<span class="number">0x00</span> || Dir-&gt;DIR_Name[<span class="number">0</span>]==<span class="number">0xe5</span>)<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(paths[<span class="number">0</span>],Dir-&gt;DIR_Name,<span class="number">11</span>)&amp;&amp;pathDepth&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> find_subdir(fat16_ins, Dir, paths, pathDepth, <span class="number">1</span>);<span class="comment">//若名称相等且pathDepth&gt;1则调用find_subdir</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(paths[<span class="number">0</span>],Dir-&gt;DIR_Name,<span class="number">11</span>)&amp;&amp;pathDepth==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>Dir结构体的定义在fat16.h文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  BYTE DIR_Name[<span class="number">11</span>];</span><br><span class="line">  BYTE DIR_Attr;</span><br><span class="line">  BYTE DIR_NTRes;</span><br><span class="line">  BYTE DIR_CrtTimeTenth;</span><br><span class="line">  WORD DIR_CrtTime;</span><br><span class="line">  WORD DIR_CrtDate;</span><br><span class="line">  WORD DIR_LstAccDate;</span><br><span class="line">  WORD DIR_FstClusHI;</span><br><span class="line">  WORD DIR_WrtTime;</span><br><span class="line">  WORD DIR_WrtDate;</span><br><span class="line">  WORD DIR_FstClusLO;</span><br><span class="line">  DWORD DIR_FileSize;</span><br><span class="line">&#125; __attribute__ ((packed)) DIR_ENTRY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>find_root函数的基本思路为遍历根目录下的每一个表项，将该表项的内容填充到Dir结构体中，判断DIR_Name是否为0(未分配)或0xe5(已删除)，若是则退出返回1，表明未找到。若不是则将当前传入路径与DIR_Name进行比较，若相等，则根据pathDepth判断是否还要调用find_subdir进一步查找表项。</p>
</li>
</ul>
<h3 id="6-TODO-6"><a href="#6-TODO-6" class="headerlink" title="6.TODO 6"></a>6.TODO 6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * 从子目录开始查找path对应的文件或目录，找到返回0，没找到返回1，并将Dir填充为查找到的对应目录项</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Hint1: 在find_subdir入口处，Dir应该是要查找的这一级目录的表项，需要根据其中的簇号，读取这级目录对应的扇区数据</span></span><br><span class="line"><span class="comment"> * Hint2: 目录的大小是未知的，可能跨越多个扇区或跨越多个簇；当查找到某表项以0x00开头就可以停止查找</span></span><br><span class="line"><span class="comment"> * Hint3: 需要查找名字为paths[curDepth]的文件或目录，同样需要根据pathDepth判断是否继续调用find_subdir函数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_subdir</span><span class="params">(FAT16 *fat16_ins, DIR_ENTRY *Dir, <span class="keyword">char</span> **paths, <span class="keyword">int</span> pathDepth, <span class="keyword">int</span> curDepth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ii,i, j,flag,m;</span><br><span class="line">    <span class="keyword">int</span> DirSecCnt = <span class="number">1</span>;  </span><br><span class="line">    BYTE* p;</span><br><span class="line">    BYTE <span class="built_in">buffer</span>[BYTES_PER_SECTOR];</span><br><span class="line">    WORD ClusterN, FatClusEntryVal, FirstSectorofCluster;</span><br><span class="line">    ClusterN=Dir-&gt;DIR_FstClusLO;<span class="comment">//对于FAT16，簇号存储在低16位中</span></span><br><span class="line">    FirstSectorofCluster = ((ClusterN - <span class="number">2</span>) * fat16_ins-&gt;Bpb.BPB_SecPerClus) + fat16_ins-&gt;FirstDataSector;<span class="comment">//获得第一个簇号的扇区号</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(ClusterN&gt;=<span class="number">0x0002</span> &amp;&amp; ClusterN&lt;=<span class="number">0xFFEF</span>)&#123;      </span><br><span class="line">       <span class="keyword">for</span>(ii=<span class="number">0</span>;ii&lt;fat16_ins-&gt;Bpb.BPB_SecPerClus;ii++)&#123;<span class="comment">//外层以每一簇的扇区个数为界限进行循环</span></span><br><span class="line">	   sector_read(fat16_ins-&gt;fd, FirstSectorofCluster+ii, <span class="built_in">buffer</span>);</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTES_PER_SECTOR/BYTES_PER_DIR; i++)&#123; <span class="comment">//内存以每个扇区中的FAT表项数进行循环</span></span><br><span class="line">            p=&amp;<span class="built_in">buffer</span>[i*BYTES_PER_DIR];</span><br><span class="line">            *Dir=*(DIR_ENTRY*)p;</span><br><span class="line">	   <span class="keyword">if</span>(Dir-&gt;DIR_Name[<span class="number">0</span>]==<span class="number">0x00</span> || Dir-&gt;DIR_Name[<span class="number">0</span>]==<span class="number">0xe5</span>)&#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">		   <span class="keyword">break</span>;</span><br><span class="line">	   &#125;              </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(paths[curDepth],Dir-&gt;DIR_Name,<span class="number">11</span>))</span><br><span class="line">              <span class="keyword">if</span>(curDepth+<span class="number">1</span>&lt;pathDepth)</span><br><span class="line">                  <span class="keyword">return</span> find_subdir(fat16_ins, Dir, paths, pathDepth, curDepth+<span class="number">1</span>);		  </span><br><span class="line">		       <span class="keyword">else</span></span><br><span class="line">		          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">FatClusEntryVal = fat_entry_by_cluster(fat16_ins, ClusterN);</span><br><span class="line">ClusterN=FatClusEntryVal;</span><br><span class="line">FirstSectorofCluster = ((ClusterN - <span class="number">2</span>) * fat16_ins-&gt;Bpb.BPB_SecPerClus) + fat16_ins-&gt;FirstDataSector;<span class="comment">//获得下一个簇的第一个扇区号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该函数是通过簇号在数据区中寻找子目录的表项，先通过已获得的根目录的表项得到首簇号，然后得到该簇号所对应的第一个扇区号。循环时，外层循环次数为每一簇对应的扇区数，内层循环次数为每个扇区对应的表项数，内层循环结束后，要判断下一个簇的簇号及其对应的第一个扇区号。具体查找过程与find_root的过程类似。</p>
<h3 id="7-TODO-7-amp-TODO-8"><a href="#7-TODO-7-amp-TODO-8" class="headerlink" title="7.TODO 7 &amp; TODO 8"></a>7.TODO 7 &amp; TODO 8</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fat16_readdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">void</span> *<span class="built_in">buffer</span>, <span class="keyword">fuse_fill_dir_t</span> filler,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">off_t</span> offset, struct fuse_file_info *fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FAT16 *Vol;</span><br><span class="line">  BYTE sector_buffer[BYTES_PER_SECTOR];</span><br><span class="line">  <span class="keyword">int</span> RootDirCnt = <span class="number">1</span>, DirSecCnt = <span class="number">1</span>, i;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fuse_context</span> *<span class="title">context</span>;</span></span><br><span class="line">  context = fuse_get_context();</span><br><span class="line">  Vol = (FAT16 *) context-&gt;private_data;</span><br><span class="line"></span><br><span class="line">  sector_read(Vol-&gt;fd, Vol-&gt;FirstRootDirSecNum, sector_buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(path, <span class="string">"/"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    DIR_ENTRY Root;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment">     * 将root directory下的文件或目录通过filler填充到buffer中</span></span><br><span class="line"><span class="comment">     * 注意不需要遍历子目录</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Vol-&gt;Bpb.BPB_RootEntCnt; i++) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(&amp;Root, &amp;sector_buffer[((i - <span class="number">1</span>) * BYTES_PER_DIR) % BYTES_PER_SECTOR], BYTES_PER_DIR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​      </span><br><span class="line">​      <span class="keyword">if</span> (Root.DIR_Name[<span class="number">0</span>] == <span class="number">0x00</span> || Root.DIR_Name[<span class="number">0</span>]==<span class="number">0xe5</span>) &#123;</span><br><span class="line">​        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">​      &#125;</span><br><span class="line">​      </span><br><span class="line">​      <span class="keyword">if</span> ((Root.DIR_Attr == ATTR_ARCHIVE || Root.DIR_Attr == ATTR_DIRECTORY) &amp;&amp; Root.DIR_Name[<span class="number">0</span>]!=<span class="number">0xE5</span>) &#123;</span><br><span class="line">​        <span class="keyword">const</span> <span class="keyword">char</span> *filename = (<span class="keyword">const</span> <span class="keyword">char</span> *) path_decode(Root.DIR_Name);</span><br><span class="line">​        filler(<span class="built_in">buffer</span>, filename, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">​      &#125;</span><br><span class="line">​      </span><br><span class="line">​      <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span> &amp;&amp; i != Vol-&gt;Bpb.BPB_RootEntCnt) &#123;</span><br><span class="line">​        sector_read(Vol-&gt;fd, Vol-&gt;FirstRootDirSecNum + RootDirCnt, sector_buffer);</span><br><span class="line">​        RootDirCnt++;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">​    DIR_ENTRY Dir;</span><br><span class="line">​      </span><br><span class="line">    <span class="comment">/** <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment">     * 通过find_root获取path对应的目录的目录项，</span></span><br><span class="line"><span class="comment">     * 然后访问该目录，将其下的文件或目录通过filler填充到buffer中，</span></span><br><span class="line"><span class="comment">     * 同样注意不需要遍历子目录</span></span><br><span class="line"><span class="comment">     * Hint: 需要考虑目录大小，可能跨扇区，跨簇</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">      </span><br><span class="line">    find_root(Vol, &amp;Dir, path);  </span><br><span class="line">    WORD ClusterN = Dir.DIR_FstClusLO;</span><br><span class="line">    WORD FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN);</span><br><span class="line">    WORD FirstSectorofCluster = ((ClusterN - <span class="number">2</span>) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector;</span><br><span class="line">    </span><br><span class="line">    sector_read(Vol-&gt;fd, FirstSectorofCluster, sector_buffer); </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; Dir.DIR_Name[<span class="number">0</span>] != <span class="number">0x00</span> &amp;&amp; Dir.DIR_Name[<span class="number">0</span>]!=<span class="number">0xe5</span> ; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ClusterN&lt;<span class="number">0x0002</span> || ClusterN&gt;<span class="number">0xFFEF</span>)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">memcpy</span>(&amp;Dir, &amp;sector_buffer[((i - <span class="number">1</span>) * BYTES_PER_DIR) % BYTES_PER_SECTOR], BYTES_PER_DIR);  </span><br><span class="line">      <span class="keyword">if</span> ((Dir.DIR_Attr == ATTR_ARCHIVE || Dir.DIR_Attr == ATTR_DIRECTORY) &amp;&amp; Dir.DIR_Name[<span class="number">0</span>]!=<span class="number">0xE5</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *filename = (<span class="keyword">const</span> <span class="keyword">char</span> *) path_decode(Dir.DIR_Name);</span><br><span class="line">        filler(<span class="built_in">buffer</span>, filename, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span>) &#123;  <span class="comment">//一个扇区的表项遍历结束 </span></span><br><span class="line">        <span class="keyword">if</span> (DirSecCnt &lt; Vol-&gt;Bpb.BPB_SecPerClus) &#123;</span><br><span class="line">          sector_read(Vol-&gt;fd, FirstSectorofCluster + DirSecCnt, sector_buffer);<span class="comment">//读取该簇的下一个扇区</span></span><br><span class="line">          DirSecCnt++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则读取下一个簇的第一个扇区号</span></span><br><span class="line">          <span class="keyword">if</span> (FatClusEntryVal == <span class="number">0xffff</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     </span><br><span class="line">          ClusterN = FatClusEntryVal; </span><br><span class="line">          FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN);</span><br><span class="line">          FirstSectorofCluster = ((ClusterN - <span class="number">2</span>) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector;</span><br><span class="line">          sector_read(Vol-&gt;fd, FirstSectorofCluster, sector_buffer);</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">          DirSecCnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：fat16_readdir函数用来读取相应目录所对应的文件内容，其具体操作过程分为两步：</p>
<ul>
<li><p>当传入路径为’/‘时进行单独处理，由于’/‘代表根目录，所以当传入路径为’/‘时，通过遍历根目录中的每一个表项将根目录下的所有内容全部通过filler填充到buffer中，每当一个扇区中的表项遍历结束需要读取下一个扇区；</p>
</li>
<li><p>当传入路径为其它时，先调用find_root函数来获得该路径所对应的表项，然后到数据区取数据，具体的寻找过程为先获得首簇号的第一个扇区号，然后对该扇区中的每个表项进行遍历，通过filler读入到buffer中，若该扇区中的表项遍历结束判断该簇中的扇区是否遍历结束，若是则获取下一簇，否则继续读取该簇的下一个扇区。</p>
</li>
<li><p>由于文件可操作的属性不同，如图：</p>
<p><img src="/2020/05/05/OS%E5%AE%9E%E9%AA%8C/16.PNG" alt="16"></p>
<p>只有文件为子目录或存档时方可进行读取，且为了避免将已删除的文件读入，需判断DIR_Name不是0xe5。</p>
</li>
</ul>
<h3 id="8-TODO-9"><a href="#8-TODO-9" class="headerlink" title="8.TODO 9"></a>8.TODO 9</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * 从path对应的文件的offset字节处开始读取size字节的数据到buffer中，并返回实际读取的字节数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Hint: 文件大小属性是Dir.DIR_FileSize；当offset超过文件大小时，应该返回0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fat16_read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">off_t</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">               struct fuse_file_info *fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  BYTE *sector_buffer = <span class="built_in">malloc</span>((<span class="built_in">size</span> + offset) * <span class="keyword">sizeof</span>(BYTE));<span class="comment">//开辟一个大小为size+offset的空间</span></span><br><span class="line"></span><br><span class="line">  FAT16 *Vol;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fuse_context</span> *<span class="title">context</span>;</span></span><br><span class="line">  context = fuse_get_context();</span><br><span class="line">  Vol = (FAT16 *) context-&gt;private_data;</span><br><span class="line"></span><br><span class="line">  DIR_ENTRY Dir;</span><br><span class="line">  find_root(Vol, &amp;Dir, path);</span><br><span class="line"></span><br><span class="line">  WORD ClusterN = Dir.DIR_FstClusLO;</span><br><span class="line">  WORD FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN);</span><br><span class="line">  WORD FirstSectorofCluster = ((ClusterN - <span class="number">2</span>) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="built_in">size</span> + offset; i += BYTES_PER_SECTOR, j++) &#123;</span><br><span class="line">    sector_read(Vol-&gt;fd, FirstSectorofCluster + j, sector_buffer + i);<span class="comment">//读取每个扇区内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((j + <span class="number">1</span>) % Vol-&gt;Bpb.BPB_SecPerClus == <span class="number">0</span>) &#123;<span class="comment">//获取下一个簇的簇号及其对应第一个扇区号</span></span><br><span class="line">    </span><br><span class="line">      ClusterN = FatClusEntryVal;</span><br><span class="line">      <span class="keyword">if</span> (FatClusEntryVal == <span class="number">0xffff</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//若读到末尾处时直接跳出循环</span></span><br><span class="line">          &#125;</span><br><span class="line">      FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN);</span><br><span class="line">    </span><br><span class="line">      FirstSectorofCluster = ((ClusterN - <span class="number">2</span>) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector;</span><br><span class="line">    </span><br><span class="line">      j = <span class="number">-1</span>;<span class="comment">//j++后变为0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (offset &lt; Dir.DIR_FileSize) &#123;<span class="comment">//读取offset偏移处的内容</span></span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="built_in">buffer</span>, sector_buffer + offset, <span class="built_in">size</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;<span class="comment">//否则size为0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(sector_buffer);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：该函数的功能为：从path对应的文件的offset字节处开始读取size字节的数据到buffer中，并返回实际读取的字节数。故开辟一个大小为size+offset的空间，读取每个扇区内容，当该簇结束且还未到达offset处时，继续获取下一个簇的簇号及其对应第一个扇区号，最后当offset小于文件大小时，从offset处读入size大小的数据，并返回字节数，否则返回字节数为0。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Lessons/" rel="tag"># Lessons</a>
              <a href="/tags/FAT/" rel="tag"># FAT</a>
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/05/DOM%E7%AC%94%E8%AE%B0/" rel="prev" title="DOM笔记">
      <i class="fa fa-chevron-left"></i> DOM笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/05/bomblab/" rel="next" title="bomblab">
      bomblab <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、实验内容及要求"><span class="nav-number">1.</span> <span class="nav-text">一、实验内容及要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、实验准备工作"><span class="nav-number">2.</span> <span class="nav-text">二、实验准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-熟悉使用FUSE"><span class="nav-number">2.1.</span> <span class="nav-text">1.熟悉使用FUSE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-FAT文件系统"><span class="nav-number">2.2.</span> <span class="nav-text">2.FAT文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、实验操作过程"><span class="nav-number">3.</span> <span class="nav-text">三、实验操作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-TODO-1"><span class="nav-number">3.1.</span> <span class="nav-text">1.TODO 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TODO-2"><span class="nav-number">3.2.</span> <span class="nav-text">2.TODO 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-TODO-3"><span class="nav-number">3.3.</span> <span class="nav-text">3.TODO 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-TODO-4"><span class="nav-number">3.4.</span> <span class="nav-text">4.TODO 4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-TODO-5"><span class="nav-number">3.5.</span> <span class="nav-text">5.TODO 5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-TODO-6"><span class="nav-number">3.6.</span> <span class="nav-text">6.TODO 6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-TODO-7-amp-TODO-8"><span class="nav-number">3.7.</span> <span class="nav-text">7.TODO 7 &amp; TODO 8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-TODO-9"><span class="nav-number">3.8.</span> <span class="nav-text">8.TODO 9</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">般若</p>
  <div class="site-description" itemprop="description">般若的blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BoRe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
