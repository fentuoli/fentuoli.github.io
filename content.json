[{"title":"编译原理之文法分析","date":"2020-05-05T00:37:54.000Z","path":"2020/05/05/编译原理之文法分析/","text":"自顶向下：采用回溯 递归向下：对每个非终结符进行分治讨论 LL(1）分析算法： 从左向右，最左推导，采用一个前看符号 LL(1)分析表： 弹出非终结符后应该压入哪条产生式的右部 FIRST集计算规则：1. N-&gt;a 并入 N-&gt;M1M2M3… M1的FIRST并入N的FIRST 直至第一个推不出空的非终结符的FIRST并入N的FIRST 构造LL(1)分析表，将FIRST推广到任意串上 每个表项只有一个，称为LL(1)文法 无冲突要求两条FIRST_S的交集为空 FOLLOW集用来判断当一个非终结符可以推出空时，什么字符（产生式规则）可以跟在它后面 FOLLOW计算规则： 从一条产生式的最后一个字符开始进行判断 采用不动点算法，直至不发生改变 计算FIRST_S:若产生式右部均为NULLABLE，则将左部非终结符的FOLLOW也加进去 LL(1)冲突解决：1. 消除左递归 提取左公因子LR(0)分析算法：自底向上 判断能否进行规约 最右推导的逆过程 将栈上的右部弹掉，压入左部 从左向右读入程序，最右推导，不用前看符号 缺点： 延迟错误发现时机，可能包含移进-规约冲突 LR(0)分析表： Sn后的n指项目序号，Rn后的n值第几条文法符号 ACTION和GOTO表 SLR分析算法： 与LR(0)区别：对于状态i上的项目X-&gt;α●，仅对y∈FOLLOW(X)添加ACTION[i,y] 优点： 减少需要规约的情况 可能去除移进规约冲突 缺点： 移进规约冲突仍可能存在 LR(1)分析算法： 与LR(0)相比：仅闭包的计算不同：对项目[X-&gt;α●Yβ,a]，添加[Y-&gt;●γ，b]到项目集，其中b∈FIRST_S(βα) 如果有移进规约冲突则不是LR(1)文法 二义性文法无法使用LR分析法 二义性文法的处理方法： 优先级 结合性 悬空else LALR分析算法： 把类似的项目集进行合并 可能带来规约规约冲突 补充： SLR(1)判断规则：方法一：画出文法的LR(0)自动机，如果没有移进–规约冲突，即shift–reduce 冲突，则该文法是SLR(1)文法 LALR(1)和LR(1)的判断规则：画出文法的LR(1)自动机，如果没有同心项且没有状态冲突，则该文法是LALR(1)文法；如果有同心项且合并同心项有状态冲突，则是LR（1）文法 证明是LL(1)文法： ：对任意两个产生式A→α|β 都有：1） First(α )∩First(β )=Φ2）若 β⇒* ε, 则First(A)∩Follow(A)=Φ 正则表达式： 不能用于配对或嵌套 表示给定结构的固定次数的重复或没有指定次数的重复","comments":true,"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://fentuoli.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"写给自己的博客","date":"2020-04-30T13:07:15.000Z","path":"2020/04/30/前言/","text":"创建这个博客是为了鼓励自己能阶段性地总结学过的东西，改掉学过就忘的毛病。我把自己踩过的坑，以及解决方案写上来，也希望对其他人有所帮助。 愿与君共勉！","comments":true,"tags":[{"name":"normal","slug":"normal","permalink":"http://fentuoli.github.io/tags/normal/"},{"name":"ab","slug":"ab","permalink":"http://fentuoli.github.io/tags/ab/"}]}]