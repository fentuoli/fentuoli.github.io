[{"title":"集成学习(上)-day1-机器学习初探","date":"2021-03-15T12:58:27.000Z","path":"2021/03/15/集成学习-上-day1/","text":"从今天起开始记录参加Datawhale第23期组队学习之集成学习的学习心得，集成学习的总共学习时长为3个月，希望自己结束后有所收获！ 由于学习的内容主要来自于github上的pdf文档，且我的学习笔记中摘抄、借鉴了学习文档中的内容故将github的链接附在这里：https://github.com/datawhalechina/team-learning-data-mining/tree/master/EnsembleLearning 第一天的学习内容非常简单，只是熟悉一下学习内容，讲述了什么是机器学习，机器学习的类型，并举了几个实际的例子。 简单总结一下：机器学习分为有监督学习和无监督学习 有监督学习：给定某些特征去估计因变量，即有因变量y的存在。 无监督学习：给定某些特征但不给定因变量，建模的目的是学习数据本身的结构和关系。 有监督学习又可分为回归和分类 补充： sklearn自带多个数据集，通过from sklearn.datasets import [数据集]可进行调用，使用时当成字典使用，如： 1234iris = load_iris()print(iris.data)print(iris.target)print(iris.DESCR)","comments":true,"tags":[{"name":"Datawhale","slug":"Datawhale","permalink":"http://fentuoli.github.io/tags/Datawhale/"},{"name":"集成学习","slug":"集成学习","permalink":"http://fentuoli.github.io/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"}]},{"title":"AVL树","date":"2020-05-05T11:40:51.000Z","path":"2020/05/05/AVL树/","text":"用AVL树原理实现的可以对数据进行反复搜索与删除操作功能的代码 EXPT 实验要求 ​ 实现一个简单的数据库系统。该数据库系统需要处理用户的数据库插入和查询语句，并输出相应的输出。具体来说，用户的输入共包含若干条插入语句和查询语句。其中每条插入语句包含一个非负整数表示需要插入的数据。每条查询语句包含一个整数表示待查询的键值，若该键值存在则直接输出该键值，否则输出数据库中比该键值小的最大键值。 实现算法：由于要在最短时间内对数据进行反复搜索与删除操作，通过建立二叉搜索树可以使得每次搜索与删除操作的时间为Ο(h)，但建立普通的二叉树有可能操作时间仍为Ο(n)，但创建红黑树维护又不方便，故建立平衡搜索树(AVL树)来实现功能。 AVL树： AVL树是一种高度平衡的平衡二叉树，树中的任意节点的左右子树的高度之差不超过1。如果将二叉树上结点的平衡因子BF，定义为该结点的左子树与右子树的高度之差，根据AVL树的定义，AVL树中的任意结点的平衡因子只可能是-1（右子树高于左子树）、0或者1（左子树高于右子树），不平衡时需要进行左旋或右旋来维护AVL的平衡性。 AVL树的结构定义： 123456789struct Node&#123; int key; int height;//用于表示当前结点的高度，叶结点的高度为1 BST left; BST right; BST parent;&#125;; AVL树的旋转操作： 情况1 ​ 右旋就是使a、b进行右旋1/4圆，使得b节点作为父节点，a节点变为b节点的右节点，b的左子树在经过右旋操作后仍是b的左子树。如果b有右子树。那么右旋后b的右子树将成为a的左子树。 ​ 左旋是右旋对称的过程。当二叉树插入或者删除一个节点时，如果破坏了树的平衡性，就会根据树的失衡情况进行旋转操作，如果左子树高于右子树，则右旋，如果右子树高于左子树，则左旋。 还有一种需要进行两次旋转的情况： 情况2 ​ 如果节点插入到a的左子树的右节点，则需要先左旋再右旋来重新平衡树。同理，如果节点插入到a的右子树的左子节点，则需要先右旋再左旋来重新平衡树。如果直接进行右旋,生成的树将仍然是失衡的。 寻找前驱：如果是新出现的值，由于每一个新插入的结点只有可能成为叶结点，故当该结点成为其父结点的左结点时，则按上图所示方式寻找B的前驱A，当该结点成为其父结点的右结点时，直接返回其父结点。如果能找到则直接返回该结点。 关键代码讲解： 插入结点： 12345678910111213141516171819202122232425262728293031BST avl_insertnode(BST root, int data)//与二叉树插入方式类似，只是插入后要对该路径上的结点的height值进行更新，并维护其平衡性&#123; BST current = root; if(current) &#123; while (current-&gt;key != data) &#123; if (data &lt; current-&gt;key) &#123; if (current-&gt;left) current = current-&gt;left; else &#123; current-&gt;left = avl_create_node(data, current); current = current-&gt;left; &#125; &#125; else if (data &gt; current-&gt;key) &#123; if (current-&gt;right) current = current-&gt;right; else &#123; current-&gt;right = avl_create_node(data, current); current = current-&gt;right; &#125; &#125; else return root; &#125; do &#123; current = current-&gt;parent; avl_update_height(current); current = avl_balance(current); &#125; while (current-&gt;parent); &#125;else&#123; current = avl_create_node(data,NULL); &#125; return current;&#125; 维护平衡性： 1234567891011121314151617181920BST avl_balance(BST root)&#123; if (height(root-&gt;left) - height(root-&gt;right) &gt; 1) &#123;//如果左子树深度大 if (height(root-&gt;left-&gt;left) &gt; height(root-&gt;left-&gt;right)) &#123;//对应上图情况1 root = avl_rotate_right(root); &#125; else &#123;//对应上图情况2 avl_rotate_left(root-&gt;left); root = avl_rotate_right(root); &#125; &#125; else if (height(root-&gt;right) - height(root-&gt;left) &gt; 1) &#123;//如果右子树深度大，与左子树对称 if (height(root-&gt;right-&gt;right) &gt; height(root-&gt;right-&gt;left)) &#123; root = avl_rotate_left(root); &#125; else &#123; avl_rotate_right(root-&gt;right); root = avl_rotate_left(root); &#125; &#125; return root;&#125; 左旋与右旋： 1234567891011121314151617BST avl_rotate_left(BST root)//旋转方法参考上图情况1与情况2&#123; BST right_root = root-&gt;right; if (root-&gt;parent) &#123; if (root-&gt;parent-&gt;right == root) root-&gt;parent-&gt;right = right_root; else root-&gt;parent-&gt;left = right_root; &#125; right_root-&gt;parent = root-&gt;parent; root-&gt;right = right_root-&gt;left; if (root-&gt;right) root-&gt;right-&gt;parent = root; right_root-&gt;left = root; root-&gt;parent = right_root; avl_update_height(root); avl_update_height(right_root); return right_root;&#125;//右旋情况对称 算法复杂度分析：旋转、插入、删除、寻找前驱操作均可以在Ο(lgn)的时间复杂度内完成。","comments":true,"tags":[{"name":"AVL","slug":"AVL","permalink":"http://fentuoli.github.io/tags/AVL/"},{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://fentuoli.github.io/tags/Algorithm/"}]},{"title":"红黑树","date":"2020-05-05T11:34:49.000Z","path":"2020/05/05/红黑树/","text":"在做红黑树插入与删除操作时，有很多地方总是弄不明白，之后看了一篇博文，讲解非常清楚，特意记录在这里！ https://blog.csdn.net/justdoithai/article/details/52670875","comments":true,"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://fentuoli.github.io/tags/Algorithm/"},{"name":"Lesson","slug":"Lesson","permalink":"http://fentuoli.github.io/tags/Lesson/"},{"name":"Red-Black Tree","slug":"Red-Black-Tree","permalink":"http://fentuoli.github.io/tags/Red-Black-Tree/"}]},{"title":"huffman","date":"2020-05-05T10:56:24.000Z","path":"2020/05/05/huffman/","text":"说明：本实验实现了利用huffman原理进行压缩和解压功能的代码 一、问题描述：构建哈夫曼树进行编码和解码： 基础功能： 输入电文字符串 统计电文字符集和每种字符在电文中出现的次数 构建huffman树 产生每种字符的huffman编码 将电文串翻译成比特流 对电文比特流进行解码 最终目的：用huffman压缩技术实现对任意文件的压缩和解压缩处理 要求对所有的文件类型进行压缩，压缩之后的文件后缀名为huff。同时，可以对所有后缀名为huff的压缩文件进行解压缩。 输入与输出： 在程序中用fopen，rb打开一个文件，读入字符串，将文件翻译成比特流之后，用wb+建立一个后缀为.huff的新文件，将比特流写入；在进行解码时，用fopen,rb打开.huff文件，将解压后的字符写入到一个与原文件后缀相同的新文件中，则压缩与解压缩完成。 二、算法描述： 数据结构描述： （1） 定义两个结构体变量： 12345678910111213141516171819struct information&#123; unsigned char data; char bytes[100];&#125;;struct HT&#123; int weight; int lchild,rchild,parent; unsigned char data; char bytes[100];&#125;; ​ 其中struct information用于存储不同字符的信息，data为字符值，bytes为该字符对应的比特流；struct HT用于保存所建立的哈夫曼树中每个节点的信息，weight为该节点的权值，lchild,rchild,parent分别为该节点左孩子，有孩子和双亲的序号，data为该节点所对应的字符，bytes为该节点字符对应的比特流； （2） 定义struct information型数组code用于存储不同字符，struct HT型数组tree用于存储哈夫曼树节点信息； （3） unsigned char类型数组original_alpha用于存储读入的每个字符； （4）int类型值root,total和difnum分别代表根节点的序号，读入的总字符数和读入文件中不同的字符个数。 程序结构描述： （1） main函数：读入字符，将不同字符存储到tree中并计算权值； （2） 函数声明：int creatHT( ); ​ 该函数用于建哈夫曼树，即在tree数组保存的所有字符中找两个权值最小的作为叶节点，将其权值的和作为新节点的权值纳入到tree中，将已找到的节点进行标记表示不可用，然后继续上面的过程直到所有节点被找完。 （3） 函数声明：int find(int num); ​ 该函数用于在tree数组保存的所有字符中找两个权值最小节点，被creatHT函数所调用。 （4） 函数声明：void encode( ); ​ 该函数用于计算每个字符所对应的比特流，从根节点开始，左子树叶节点的比特流为其双亲的比特流在后面加1，右子树叶节点的比特流为其双亲的比特流在后面加0，直至到叶节点结束。 （5） 函数声明：void compress( ); ​ 该函数用于进行压缩操作，将原始读入的每个字符找到其对应的比特流，每8位2进制为一组将其以字符的形式压入到.huff文件中，最后一组不足8位的在后面补0； （6） 函数声明：void uncompress( ); ​ 该函数用于进行解压缩操作，打开.huff文件，读入字符将其转化为8位2进制码，若不足8位则在前面补0，从根节点开始，2进制数为1向左指，2进制数为0向右指，读出的字符保存到字符型数组alpha中，最后将alpha数组中的字符读入到新生成的与原文件后缀名相同的文件中，则解压缩完成。 三、关键代码解释 创建哈夫曼树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int creatHT()//创建哈夫曼树&#123; int i,j,d; for(i=topT; i&lt;=2*topT; i++) &#123; d=find(i-1);//在tree数组保存的所有字符中找两个权值最小的作为叶节点，将其权值的和作为新节点的权值纳入到tree中，将已找到的节点进行标记表示不可用 if(d==2)//找到 &#123; tree[s1].parent=i; tree[s2].parent=i; tree[i].lchild=s1; tree[i].rchild=s2; tree[i].weight=tree[s1].weight+tree[s2].weight; &#125; else break; &#125; root=i-1; return root;&#125;int find(int num)//寻找两个权值最小的树节点&#123; int i,t=0; int m1=999999; for(i=0;i&lt;=num;i++)//找第一个权值最小的树节点 &#123; if(tree[i].parent==-1) &#123; t=1; if(tree[i].weight&lt;m1) &#123; m1=tree[i].weight; s1=i; &#125; &#125; &#125; tree[s1].parent=-2; m1=999999; for(i=0;i&lt;=num;i++)//找第二个权值最小的树节点 &#123; if(tree[i].parent==-1) &#123; t=2; if(tree[i].weight&lt;m1) &#123; m1=tree[i].weight; s2=i; &#125; &#125; &#125; return t;&#125; 对树节点的每个字符进行编码 123456789101112131415161718192021222324252627282930313233343536373839404142void encode( )//对树节点的每个字符进行编码&#123; char a=1,b=0,str[2],str1[2],temp[100]; int i=0,j,n; itoa(a,str,2); itoa(b,str1,2); queue[tail]=root; tail++; str[1]='\\0'; str1[1]='\\0'; i=0; tree[queue[head]].bytes[0]='\\0';//树根结点无编码，从根结点开始对树节点进行编码 while(head!=tail) &#123; strcpy(temp,tree[queue[head]].bytes); if(tree[queue[head]].lchild!=-1)//左子树后面补1 &#123; strcat(temp,str); strcpy(tree[tree[queue[head]].lchild].bytes,temp); queue[tail]=tree[queue[head]].lchild; tail++; &#125; strcpy(temp,tree[queue[head]].bytes);//右子树后面补0 if(tree[queue[head]].rchild!=-1) &#123; strcat(temp,str1); strcpy(tree[tree[queue[head]].rchild].bytes,temp); queue[tail]=tree[queue[head]].rchild; tail++; &#125; if(tree[queue[head]].lchild==-1&amp;&amp;tree[queue[head]].rchild==-1) &#123; code[i].data=tree[queue[head]].data; strcpy(code[i].bytes,tree[queue[head]].bytes); n=strlen(code[i].bytes); code[i].bytes[n]='\\0';//得出相应比特流 i++; &#125; head++; &#125; difnum=i;&#125; 对字符进行压缩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void compress( )//对字符进行压缩&#123; FILE *fp1,*fp2; if((fp1=fopen(\"text.huff\",\"rb\"))==NULL) &#123; printf(\"error on open \"); &#125; int i,j,k,m,n,n1,count=0,a=0,r,b,temp[9],t=0,p,q; char str[2]=&#123;0&#125;; k=0; n=0; m=0; p=0; for(i=0; i&lt;total; i++) &#123; for(j=0; j&lt;difnum; j++) &#123; if(original_alpha[i]==code[j].data)//寻找原文件中的每个字符所对应的比特流 &#123; k=0; n=n+strlen(code[j].bytes); n1=strlen(code[j].bytes); while(n1&gt;0) &#123; if(p&lt;8)//每8个2进制码分为1组 &#123; temp[p]=code[j].bytes[k]-'0'; k++; p++; &#125; if(p==8) &#123; for(q=0;q&lt;8;q++) during[m]=during[m]+temp[q]*pow(2,7-q);//累加保存到during中 m++; p=0; &#125; n1--; &#125; break; &#125; &#125; &#125; if(n%8==0) for(j=0;j&lt;m;j++) fputc(during[j],fp1);//写入到压缩文件中 else &#123; for(i=0;i&lt;p;i++)//如果不足8位则直接写入 &#123; during[m]=during[m]+temp[i]*pow(2,7-i); &#125; for(j=0;j&lt;=m;j++) fputc(during[j],fp1); &#125; fclose(fp1);&#125; 对压缩后的文件解压 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void uncompress( )//对压缩文件解压缩&#123; FILE *fp1,*fp2; int ch; int i=0,k,t=0,n,a=0; char str[2]; unsigned char alpha[10*N]; int j; j=root; if((fp1=fopen(\"text.huff\",\"rb\"))==NULL)//打开压缩文件 &#123; printf(\"error on open \"); &#125; itoa(a,str,2); str[1]='\\0'; while(1) &#123; if((ch=fgetc(fp1))==EOF) break; char str1[10]=&#123;'\\0'&#125;; char buf[10]=&#123;'0'&#125;; itoa(ch,buf,2); //将读入的每个字符转换为8位2进制码 n=strlen(buf); buf[n]='\\0'; if(n%8!=0) //若不足8位则在前面补0 &#123; n=8-n%8; for(k=0;k&lt;n;k++) strcat(str1,str); strcat(str1,buf); strcpy(buf,str1); &#125; buf[8]='\\0'; if(t==total) break; if(buf[0]=='0')//从根节点开始，读入的二进制码为1则向左子树移动，为0则向右子树移动 &#123; j=tree[j].rchild; if(tree[j].rchild==-1&amp;&amp;tree[j].lchild==-1) &#123; alpha[i]=tree[j].data;//将得到的字符存入alpha数组中 i++; t++; j=root; &#125; &#125; else//读入的二进制码为1则向左子树移动 &#123; j=tree[j].lchild; if(tree[j].rchild==-1&amp;&amp;tree[j].lchild==-1) &#123; alpha[i]=tree[j].data; i++; t++; j=root; &#125; &#125; if(t==total) break; //下面对buf[1]、buf[2]、buf[3]、buf[4]、buf[5]、buf[6]、buf[7]分别进行与buf[0]相同的操作。最后将alpha数组读入到解压后的文件中，解压即成功 四、调试分析：（1） 数据选择： ​ 测试数据为各种类型的文件，以确保压缩和解压缩程序的正确性。 （2） 遇到的问题及解决方法： 问题1：在生成每个字符的比特流后，没有在字符后加“\\0”符导致出现一些奇怪的字符，加了“\\0”后解决了这个问题； 问题2：在写入压缩文件时用wt写入导致在解压压缩文件时一直有乱码现象，后来查阅资料发现wt会在写入时在文件前加上x0A，导致出现多余字符从而解压失败，后来将wt改为wb解决了这个问题； 问题3：在解压过程中，将读入的字符转换为8位2进制码，有的不足8位，但压缩时是按照8位一组进行的压缩，故应该是2进制码前面的0丢失，刚开始没有注意到这个问题导致出错，后来不足8位的在前面补0解决了这个问题； 问题4：由于没有考虑到原文件的大小，在生成原文件每个字符对应的2进制码时是先保存到一个字符型数组中，但原文件过大会导致数组溢出。后来将程序改为一边生成2进制码一边以8位一组读入到压缩文件中解决了这个问题。 五、测试结果及分析：将测试数据的运行过程展示如下： 测试数据： 自行建立一个名为in的txt文件： ​ 其中a出现了3次，b出现了2次，c出现了5次,d,e,f,g各出现了1次，故生成哈夫曼树后计算每个字符对应的比特流a,c一样长且最短，b与d,e,f,g中任意两个一样长且比a,c长1位，d,e,f,g中剩下两个一样长且比b长1位。 如图为生成的huffman树： 将解压后的文件命名为new.txt： 如上图所示，可知压缩和解压过程正确。","comments":true,"tags":[{"name":"huffman","slug":"huffman","permalink":"http://fentuoli.github.io/tags/huffman/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://fentuoli.github.io/tags/Data-Structure/"},{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"}]},{"title":"离散事件模拟","date":"2020-05-05T10:49:48.000Z","path":"2020/05/05/离散事件模拟/","text":"说明：本实验实现的是基于离散事件驱动的银行业务的事件驱动模拟系统，其中有关键代码讲解 一、实验要求：客户业务分为两种： 第一种是申请从银行得到一笔资金，即取款或借款； 第二种是向银行投入一笔资金，即存款或还款。 ​ 银行有两个服务窗口，相应地有两个队列。客户到达银行后先排第一个队，处理每个客户业务时，如果属于第一种，且申请额超出银行现存资金总额而得不到满足，则立刻排入第二个队等候直至满足时才离开银行;否则业务处理完后立刻离开银行,每接待完一个第二种业务的客户，则顺序检查和处理(如果可能)第二个队列中的客户，对能满足的申请者予以满足,不能满足者重新排到第二个队列的队尾。注意，在此检查过程中，一旦银行资金总额少于或等于刚才第一个队列中最后一个客户(第二种业务)被接待之前的数额，或者本次已将第二个队列检查或处理了一遍，就停止检查(因为此时已不可能还有能满足者)转而继续接待第一个队列的客户。任何时刻都只开一个窗口。假设检查不需要时间，营业时间结束时所有客户立即离开银行。 ​ 写一个上述银行业务的事件驱动模拟系统，通过模拟方法求出客户在银行内逗留的平均时间。 输入格式： 第一行输入三个数N、total、close_time，分别表示来银行的总人数、银行开始营业时拥有的款额、今天预计的营业时长 之后的N行每行输入三个数a、b、c，第一个数a为客户办理的款额，用负值和正值分别表示第一类和第二类业务，第二个数b为客户来到银行的时间，第三个数c为每个客户的接待时间 输出格式： 前N行输出分别对应每个客户的等候时长 第N+1行输出为客户等候平均时长，结果去尾法保留整数即可 二、算法描述： 数据结构的描述： （1） 定义一个结构体： 123struct Customer&#123; int arrivetime,amount,tag,recvtime;&#125; ​ 用于保存每个顾客的信息，arrivetime为顾客到达时间，amount为该顾客所要存（取）钱的金额，当amount为负时表示取钱，tag用于记录该顾客在当天所有顾客中到达的次序，方便之后按顺序输出每个顾客的等待时长，recvtime表示每个客户的接待时间 （2） 定义两个struct Customer类型的队列customer1和customer2,customer1用于保存队列1中的顾客信息，customer2用于保存队列2中的顾客信息。 （3） 定义int类型的值N,total,closetime,average,time，其中N表示顾客总数，total表示银行现有的总钱数，closetime表示银行关门时间，average表示顾客平均等待时长，time表示当前时间，初始值为0。 程序结构的描述： ​ 先按次序将所有顾客办理款项总额和到达银行时间放入二维数组m中，然后依次通过判断该顾客到达时间加办理业务时间不超过银行关门时间，则将顾客信息纳入customer1中。处理每个客户业务时，如果amount&lt;0，且申请额超出银行现存资金总额total而得不到满足，则将该顾客信息从customer1队头中取出加入customer2队尾，直至满足时才从customer2中取出；否则业务处理完后便直接从customer1的队头取出,每接待完一个amount&gt;0的客户，则顺序检查和处理第二个队列中的客户，对能满足的申请者予以满足,不能满足者重新排到第二个队列的队尾。将第二个队列检查或处理了一遍后，就停止检查转而继续接待第一个队列的客户。 ​ 在每接待一个顾客前，都要计算当前时间加上平均接待时间是否超过关门时间，若超出则剩余顾客都不接待，他们的等待时间都等于银行关门时间减去到达时间；在每接待一个顾客结束后，都要将当前时间加上一个人的平均接待时间。 三、关键代码讲述123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115while(top1!=tail1)//队列1中有顾客时 &#123; if(customer1[top1].amount&lt;0)//对办理取钱事项客户的处理 &#123; a=customer1[top1];//进入队列2 customer2[tail2]=a; tail2++; top1++; temp=tail2; while(top2!=temp) &#123; if((-customer2[top2].amount)&lt;=total)//银行的钱足够客户取用 &#123; if((time+customer2[top2].recvtime)&gt;closetime)//当前时间加上接待时间超过银行关门时间，则跳过下面的处理 break; else &#123; total+=customer2[top2].amount;//银行的钱减去客户取用的钱 if(time&lt;customer2[top2].arrivetime)//当前时间小于客户到达时间 &#123; time=customer2[top2].arrivetime;//更新时间 wait[customer2[top2].tag]=time-customer2[top2].arrivetime; //求客户等待时间 time+=customer2[top2].recvtime;//求当前时间 top2++; &#125; else &#123; wait[customer2[top2].tag]=time-customer2[top2].arrivetime;//求客户等待时间 time+=customer2[top2].recvtime;//更新时间 top2++; &#125; &#125; &#125; else//银行的钱不够客户取 &#123; a=customer2[top2];//排到队尾 customer2[tail2]=a; top2++; tail2++; &#125; &#125; &#125; else//对办理存钱事项客户的处理 &#123; if((time+customer1[top1].recvtime)&gt;closetime)//判断当前客户事件能否处理完 break; else &#123; total+=customer1[top1].amount;//求银行现有总金额 if(time&lt;customer1[top1].arrivetime)//当前时间小于客户到达时间 &#123; time=customer1[top1].arrivetime;//更新时间 wait[customer1[top1].tag]=time-customer1[top1].arrivetime;//求客户等待时间 time+=customer1[top1].recvtime;//求当前时间 top1++; &#125; else &#123; wait[customer1[top1].tag]=time-customer1[top1].arrivetime; time+=customer1[top1].recvtime; top1++; &#125; temp=tail2; while(top2!=temp)//顺序判断队列2中客户的需求能否被满足 &#123; if((-customer2[top2].amount)&lt;=total)//可以被满足 &#123; if((time+customer2[top2].recvtime)&gt;closetime)//时间超出营业时间 break; else &#123; total+=customer2[top2].amount;//更新银行营业额 if(time&lt;customer2[top2].arrivetime) &#123; time=customer2[top2].arrivetime; wait[customer2[top2].tag]=time-customer2[top2].arrivetime; time+=customer2[top2].recvtime; top2++; &#125; else &#123; wait[customer2[top2].tag]=time-customer2[top2].arrivetime; time+=customer2[top2].recvtime; top2++; &#125; &#125; &#125; else//要求不能被满足 &#123; a=customer2[top2]; customer2[tail2]=a; top2++; tail2++; &#125; &#125; &#125; &#125; &#125;if(top2!=tail2)//若队列未空，则剩余客户的等待时间均为银行关门时间减去客户到达时间，求剩余顾客的等待时间 &#123; while(top2!=tail2) &#123; wait[customer2[top2].tag]=closetime-customer2[top2].arrivetime; top2++; &#125; &#125; if(top1!=tail1) &#123; while(top1!=tail1) &#123; wait[customer1[top1].tag]=closetime-customer1[top1].arrivetime; top1++; &#125; &#125; 四、调试分析：（1） 数据选择： ​ 在选择数据时要使得客户的到达时间尽可能随机，并且要包含银行关门时间已到而客户事件未处理完的情况； （2） 遇到的问题及解决方法： ​ 刚开始没有对当前时间进行正确计算导致出错，后来在每次处理完一个客户事件后都将当前时间加上平均处理时间，并且还要在每处理一个新客户时判断当前时间和该客户到达时间的早晚，若客户到达时间晚于当前时间，则将当前时间更新为该客户的到达时间； ​ 由于没有在处理每个客户事件前计算能否处理完该客户事件导致出错，故在处理每个客户事件前都要用当前时间加上平均处理时间以判断能否处理完，若不能则该客户和剩余客户的等待时间均为银行关门时间减去他们的到达时间。 五、测试结果测试数据： 4 10000 600 -2000 0 10 -11000 10 10 -10000 30 10 2000 50 10 运行结果： 数据解释： 开始时银行有存款10000元，客户交易时长10 1号客户0时到达银行，于10时办理完手续离开，此时银行有存款8000 2号客户10时到达银行，此时银行内存款不足，进入队列2 3号客户30时到达银行，此时银行内存款不足，进入队列2 4号客户50时到达银行，于60时办理完手续离开，此时银行有存款10000元。 ​ 这时扫描队列2，队列2中第一个客户2号客户的要求仍然不满足，2号客户出队再入队；此时队列2中第一个客户3号客户满足要求，因此3号客户于60时开始办理手续，于70时办理完毕离开银行，等待时间为60-30=30，此时银行有存款0元。 ​ 然后直到银行营业时间600时之前2号客户都没有离开银行，等待时间600-10=590。 ​ 四位顾客的平均等待时间为155。","comments":true,"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://fentuoli.github.io/tags/Data-Structure/"},{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"},{"name":"Discrete-Event Simulation","slug":"Discrete-Event-Simulation","permalink":"http://fentuoli.github.io/tags/Discrete-Event-Simulation/"}]},{"title":"多周期CPU","date":"2020-05-05T10:42:05.000Z","path":"2020/05/05/多周期CPU/","text":"说明：本实验为课程计算机组成原理要求实验，具体解释与完整代码参加我的github地址： https://github.com/fentuoli/multicycle-CPU 一、实验要求与内容 设计实现多周期MIPS-CPU，可执行如下指令： add, sub, and, or, xor, nor, slt addi,andi,ori,xori,slti lw,sw beq,bne,j 其中寄存器堆中R0内容恒定为0，存储器容量为256*32位 DDU：Debug and Display Unit，调试和显示单元 下载测试时，用于控制CPU运行方式和显示运行结果 数据通路中寄存器堆和存储器均需要增加1个读端口，供DDU读取并显示其中内容 数据通路 DDU显示模块 二、实验数据通路 注： I1代表I型指令，I3代表beq和bne型指令 对每个阶段的任务分析见下文对代码段的分析 三、代码逻辑分析1.定义寄存器堆123456789101112131415161718192021222324252627282930313233343536373839404142434445module regfile(input [4:0] ra0,input [4:0] ra1,input [4:0] wa,input [31:0] wd,input we,input rst,input clk,output reg [31:0] rd0,output reg [31:0] rd1 ); reg [22:0] cnt; reg [31:0] register [0:31];//32个寄存器always @(posedge clk or posedge rst)begin if(rst) begin register[0:31]=0; //寄存器初始化 end else begin if(we) //写寄存器 register[wa]&lt;=wd; else register[wa]&lt;=register[wa]; endendalways @(*)begin if(rst)//读寄存器 begin rd0=0; rd1=0; end else begin rd0=register[ra0]; rd1=register[ra1]; endend endmodule 2.定义控制信号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120module control_code(input [5:0] opcode,input [5:0] funct,input clk,output reg regdst,output reg memtoreg,output reg regwrite,output reg memread,output reg memwrite,output reg [1:0] ALUop,output reg pcwritecond,output reg [2:0] pcsource,output reg j,//便于在取指结束后就判断是否为j型指令output reg addi,//便于之后进行立即数扩展时判断是算术扩展还是逻辑扩展output reg [2:0] alusrcB );always @(opcode,funct)begin case(opcode) 6'b000000://R型 begin if(funct==6'd0) regwrite=0;//对于32'h0的空指令，写寄存器信号为0 else regwrite=1; regdst=1; memtoreg=0; memread=0; memwrite=0; ALUop=10; pcwritecond=0; pcsource=3'b000; j=0; addi=0; alusrcB=3'b000;//alusrcB的值按照上图的数据通路来定义 end 6'b100011://lw begin regdst=0; memtoreg=1; regwrite=1; memread=1; memwrite=0; ALUop=00; pcwritecond=0; pcsource=3'b000; j=0; addi=0; alusrcB=3'b010; end 6'b101011://sw begin regdst=0; memtoreg=0; regwrite=0; memread=0; memwrite=1; ALUop=00; pcwritecond=0; pcsource=3'b000; j=0; addi=0; alusrcB=3'b010; end 6'b000100,6'b000101://beq,bne begin regdst=0; memtoreg=0; regwrite=0; memread=0; memwrite=0; ALUop=01; pcwritecond=1; pcsource=3'b001; j=0; addi=0; alusrcB=3'b000; end 6'b000010://j begin regdst=0; memtoreg=0; regwrite=0; memread=0; memwrite=0; ALUop=01; pcwritecond=0; pcsource=3'b010; j=1; addi=0; alusrcB=3'b011; end default://I型 begin regdst=0; memtoreg=0; regwrite=1; memread=0; memwrite=0; ALUop=11; pcwritecond=0; pcsource=3'b000; j=0; if(opcode==6'b001000) addi=1; else addi=0; alusrcB=3'b010; end endcaseendendmodule 3.ALU运算器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677module CTR(input [1:0] ALUop,input [5:0] funct,input [5:0] opcode,output reg [3:0] ALUctr);always @(ALUop or funct)casex( &#123; ALUop,funct &#125; ) 8'b10100000:ALUctr=4'b0000;//add 8'b10100010:ALUctr=4'b0001;//sub 8'b10100100:ALUctr=4'b0010;//and 8'b10100101:ALUctr=4'b0011;//or 8'b10100110:ALUctr=4'b0100;//xor 8'b10100111:ALUctr=4'b0101;//nor 8'b10101010:ALUctr=4'b0110;//slt,slti 8'b01xxxxxx:ALUctr=4'b0001;//beq,bne(相减) 8'b00xxxxxx:ALUctr=4'b0000;//lw,sw(相加) 8'b11xxxxxx://I型指令 begin casex( &#123; ALUop,opcode &#125; ) 8'b11001000:ALUctr=4'b0000;//addi 8'b11001100:ALUctr=4'b0010;//andi 8'b11001101:ALUctr=4'b0011;//ori 8'b11001110:ALUctr=4'b0100;//xori 8'b11001010:ALUctr=4'b0110;//slti endcase endendcaseendmodule module alu(input [31:0] input1,input [31:0] input2,input [1:0] ALUop,input [5:0] funct,input [5:0] opcode,input [3:0] aluctr,input clk,input rst,output reg[31:0] alures,output reg zero);CTR control(.ALUop(ALUop),.funct(funct),.opcode(opcode),.ALUctr(aluctr));always @(*)begin if(rst) alures=32'h0000; else begin case(aluctr) 4'b0000://add alures=input1+input2; 4'b0001://sub begin alures=input1-input2; if(alures==0) zero=1; else zero=0; end 4'b0010://and alures=input1 &amp; input2; 4'b0011://or alures=input1 | input2; 4'b0100://xor alures=input1 ^ input2; 4'b0101://nor alures=~(input1 | input2); 4'b0110://slt begin if(input1 &lt; input2) alures=32'd1; else alures=32'd0; end endcase end end endmodule 4. 7段数码管控制逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105module segc(input clk,input rst,input [31:0] in,output [7:0] an,output [6:0] seg );wire rst_n;wire cout;reg pulse_1hz;reg [7:0] seg_sel;reg [3:0] seg_din; reg [22:0] cnt; seg_ctrl seg_ctrl(.x (seg_din),.sel (seg_sel),.an (an),.seg (seg) ); always@(posedge clk or posedge rst) begin if(rst) cnt &lt;= 23'h0; else if(cnt&lt;23'd5000000) cnt &lt;= cnt + 1; else cnt &lt;= 23'h0; endalways@(posedge clk )begin case(cnt[15:13]) 3'b000: begin seg_sel &lt;= 8'b1111_1110; seg_din &lt;= in[3:0]; end 3'b001: begin seg_sel &lt;= 8'b1111_1101; seg_din &lt;= in[7:4]; end 3'b010: begin seg_sel &lt;= 8'b1111_1011; seg_din &lt;= in[11:8]; end 3'b011: begin seg_sel &lt;= 8'b1111_0111; seg_din &lt;= in[15:12]; end 3'b100: begin seg_sel &lt;= 8'b1110_1111; seg_din &lt;= in[19:16]; end 3'b101: begin seg_sel &lt;= 8'b1101_1111; seg_din &lt;= in[23:20]; end 3'b110: begin seg_sel &lt;= 8'b1011_1111; seg_din &lt;= in[27:24]; end 3'b111: begin seg_sel &lt;= 8'b0111_1111; seg_din &lt;= in[31:28]; end endcase end endmodulemodule seg_ctrl(input [3:0] x,input[7:0] sel,output [7:0] an,output reg [6:0] seg);assign an=sel;always @(x)begincase(x)//从0到F7段数码管上每个引脚电平的控制 4'b0000:seg=7'b1000000; 4'b0001:seg=7'b1111001; 4'b0010:seg=7'b0100100; 4'b0011:seg=7'b0110000; 4'b0100:seg=7'b0011001; 4'b0101:seg=7'b0010010; 4'b0110:seg=7'b0000010; 4'b0111:seg=7'b1111000; 4'b1000:seg=7'b0000000; 4'b1001:seg=7'b0010000; 4'b1010:seg=7'b0100000; 4'b1011:seg=7'b0000011; 4'b1100:seg=7'b1000110; 4'b1101:seg=7'b0100001; 4'b1110:seg=7'b0000110; 4'b1111:seg=7'b0001110;endcaseendendmodule 5.顶层模块1.例化存储器12345678dist_mem_gen_0 memory( .a(writeaddr_mem), // input wire [15 : 0] a 10 .d(B), // input wire [11 : 0] d 11 .dpra(readaddr_mem), // input wire [15 : 0] dpra 12 .clk(cpuclk), // input wire clk 13 .we(memwrite1), // input wire we 14 .dpo(readdata),.spo(readdata1) ); // output wire [11 : 0] dpo 分析：使用Dual Port RAM,其中a为写地址，d为读出的数据，dpra为读地址，we为写使能。 2.定义状态和操作数123456789101112131415161718192021222324//定义状态 assign IF=4'd1,ID = 4'd2,EX_R = 4'd3,EX_I1 = 4'd4,EX_LW = 4'd5,EX_I3 = 4'd6,EX_J = 4'd7,MEM_R = 4'd8,MEM_I1 = 4'd9,MEM_LW = 4'd10,MEM_SW = 4'd11,MEM_I3 = 4'd12,WB_LW = 4'd13,EX_SW = 4'd14;//定义操作数assign opcode=IR[31:26],funct = IR[5:0],rs = IR[25:21],rt = IR[20:16],rd = IR[15:11],shamt = IR[10:6],imm = IR[15:0],jump = IR[25:0]; 3.定义选择器信号1234567891011121314151617181920212223242526272829303132//多路选择器assign IorD_mux = IorD?ALUout[9:2]:PC[9:2];assign writereg_mux = regdst?rd:rt;//写寄存器值assign writedata_mux = memtoreg?MDR:ALUout;//写存储器值assign ALUsrcA_mux = A;assign data=mem?readdata:A;//ALUsrcBalways @(posedge cpuclk)begin if(ALUsrcB==3'b000) ALUsrcB_mux=B; else if(ALUsrcB==3'b001) ALUsrcB_mux=32'd4; else if(ALUsrcB==3'b010) ALUsrcB_mux=sign_extend; else if(ALUsrcB==3'b011) ALUsrcB_mux=shift_left2;end//PCwritecond&amp;zeroalways @(current_state,PC_change,PCwritecond,zero,opcode)begin if(current_state==EX_I3) begin if(opcode==6'b000100) PC_change=PCwritecond &amp; zero ; else if(opcode==6'b000101) PC_change=PCwritecond &amp; ~zero; else PC_change=0; end else PC_change=0; 分析： 在MEM_LW阶段时，IorD为1，此时访问存储器的地址为ALU计算出的地址。 当为beq和bne型指令时，PCwritecond为1 当PC_change为1时，PC更新为当前PC+im&lt;&lt;2的值，其余指令PC_change均为0 4.扩展位操作1assign sign_extend=(imm[15]&amp;(addi|PCwritecond))?&#123; 16'hffff,imm &#125;:&#123; 16'h0000,imm &#125;; 分析：当指令为addi、beq和bne类型且最高位为1时进行算术扩展，其余进行逻辑扩展 5.由状态机控制每个周期运作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596always @(posedge cpuclk or posedge rst)begin if(rst) begin current_state=4'd1; PC&lt;=32'h0000_0000; IorD&lt;=0; end else begin case(current_state) IF://PC+4,IR更新，当前状态切换到ID begin IorD&lt;=0; PC&lt;=PC+4; IR&lt;=readdata; memwrite1&lt;=0; current_state&lt;=ID; end ID://如果为空指令，则继续取下一条指令 begin if(IR==32'h0000) current_state&lt;=IF;//状态机跳转到下一状态 else//否则根据操作码不同，切换到不同状态 begin if(opcode==6'd0) current_state&lt;=EX_R; else if(opcode==6'b100011) current_state&lt;=EX_LW; else if(opcode==6'b101011) current_state&lt;=EX_SW; else if(opcode==6'b000100 || opcode==6'b000101) current_state&lt;=EX_I3; else if(opcode==6'b000010) current_state&lt;=EX_J; else current_state&lt;=EX_I1; end end EX_R: begin current_state&lt;=MEM_R; end MEM_R: current_state&lt;=IF; EX_I1: begin current_state&lt;=MEM_I1; end MEM_I1: current_state&lt;=IF; EX_LW: begin current_state&lt;=MEM_LW; end EX_SW: begin current_state&lt;=MEM_SW; end MEM_LW: begin IorD&lt;=1;//该信号置1，从存储器中取相应值 current_state&lt;=WB_LW; end WB_LW: begin IorD&lt;=0;//该信号置0 current_state&lt;=IF; end MEM_SW: begin memwrite1&lt;=1;//写存储器信号置1 current_state&lt;=IF; end EX_I3://I3代表beq和bne类型指令 begin if(PC_change) begin shift_left2=(PC+(sign_extend&lt;&lt;2));//PC更新 PC&lt;=shift_left2; IorD&lt;=0; current_state&lt;=MEM_I3; end MEM_I3: begin current_state&lt;=IF; end EX_J: begin PC&lt;=jump_shift;//PC更新 IorD&lt;=0; current_state&lt;=IF; end endcase end end 6.定义DDU模块123456789101112131415161718192021222324252627282930assign cpuclk=cont?clk_50:step;//控制单步和连续执行assign readaddr_reg =(choose &amp; ~mem)?DDU_addr[4:0]:rs;assign readaddr_mem=(choose &amp; mem)?DDU_addr:IorD_mux;assign data=mem?readdata:A;always @(posedge clk_50 or posedge rst)begin if(rst) begin inc_ctr&lt;=1; dec_ctr&lt;=1; DDU_addr&lt;=8'd0; end else begin if(inc &amp; inc_ctr) begin DDU_addr&lt;=DDU_addr+1; inc_ctr&lt;=0; end if(~inc &amp; ~inc_ctr) inc_ctr&lt;=1; if(dec &amp; dec_ctr) begin DDU_addr&lt;=DDU_addr-1; dec_ctr&lt;=0; end if(~dec &amp; ~dec_ctr) dec_ctr&lt;=1; endend 分析： choose用于控制是否将读入地址作为访存或访问寄存器的地址 DDU_addr为读入地址 data为7段数码管上要显示的值，当mem为1时显示存储器中值，mem为0时显示相应寄存器堆中值 其中inc_ctr和dec_ctr为reg类型值，用来控制使在每个周期时钟上升沿当inc为1时，DDU_addr只递增/递减一次。 四、仿真源码及顶层模块完整源码 顶层模块完整源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341module CPU(input cont,input step,input mem,input inc,input dec,input clk,input choose,input rst,output [7:0] an,output [6:0] seg,output [7:0] MEMORY ); wire [31:0] data;reg [7:0] DDU_addr;reg [7:0] DDU;reg run;reg step_ctr; reg inc_ctr;reg dec_ctr; reg [3:0] current_state;reg [3:0] next_state;reg [31:0] PC,IR;reg PCwrite;reg IorD;reg IRwrite;reg ALUsrcA;reg [31:0] writedata_mem;reg PC_change;reg [31:0] PCsource_mux;reg memwrite1;reg [31:0] ALUsrcB_mux;reg [31:0] shift_left2;wire [5:0] opcode_DDU;wire cpuclk;wire [2:0] ALUsrcB;wire [31:0] ALUout_shift;wire [2:0] PCsource;wire PCwritecond;wire addi;wire j;wire memread;wire memwrite;wire memtoreg;wire [1:0] ALUop;wire regwrite;wire regdst;wire [31:0] A,B;wire [31:0] readdata;wire [31:0] readdata1;wire [4:0] readaddr_reg;wire [31:0] MDR;wire zero;wire set_1;wire [3:0] aluctr;wire [7:0] readaddr_mem,writeaddr_mem;wire [31:0] sign_extend;wire [5:0] opcode,funct;wire [4:0] rs,rt,rd,shamt;wire [15:0] imm;wire [25:0] jump;wire [31:0] jump_shift;wire [31:0] ALUout;wire [31:0] writedata_mux,ALUsrcA_mux;wire [7:0] IorD_mux;wire [4:0] writereg_mux;wire locked;wire clk_50;wire [3:0] IF,ID,EX_R,EX_I1,EX_LW,EX_SW,EX_I3,EX_J,MEM_R,MEM_I1,WB_LW,MEM_SW,MEM_I3,MEM_LW;//定义状态 assign IF=4'd1,ID = 4'd2,EX_R = 4'd3,EX_I1 = 4'd4,EX_LW = 4'd5,EX_I3 = 4'd6,EX_J = 4'd7,MEM_R = 4'd8,MEM_I1 = 4'd9,MEM_LW = 4'd10,MEM_SW = 4'd11,MEM_I3 = 4'd12,WB_LW = 4'd13,EX_SW = 4'd14;//定义操作数assign opcode=IR[31:26],funct = IR[5:0],rs = IR[25:21],rt = IR[20:16],rd = IR[15:11],shamt = IR[10:6],imm = IR[15:0],jump = IR[25:0];segc segc(.clk (clk_50),.rst (rst),.in (data),.an (an),.seg (seg)); //例化内存dist_mem_gen_0 memory( .a(writeaddr_mem), // input wire [15 : 0] a 10 .d(B), // input wire [11 : 0] d 11 .dpra(readaddr_mem), // input wire [15 : 0] dpra 12 .clk(cpuclk), // input wire clk 13 .we(memwrite1), // input wire we 14 .dpo(readdata),.spo(readdata1) ); // output wire [11 : 0] dpo//例化时钟clk_wiz_0 clk_wiz_0( .clk_in1(clk), .clk_out1(clk_50), .locked(locked), .reset(rst) ); //例化寄存器堆regfile REGFILE(.ra0(readaddr_reg),.ra1(rt),.wa(writereg_mux),.wd(writedata_mux),.we(regwrite),.rst(rst),.clk(cpuclk),.rd0(A),.rd1(B));//例化控制信号control_code CONTROL(.opcode(opcode),.funct(funct),.clk(cpuclk),.regdst(regdst),.memtoreg(memtoreg),.regwrite(regwrite),.memread(memread),.memwrite(memwrite),.ALUop(ALUop),.pcwritecond(PCwritecond),.pcsource(PCsource),.j(j),.addi(addi),.alusrcB(ALUsrcB));//例化ALUalu ALU(.input1(ALUsrcA_mux),.input2(ALUsrcB_mux),.ALUop(ALUop),.funct(funct),.opcode(opcode),.aluctr(aluctr),.clk(cpuclk),.rst(rst),.alures(ALUout),.zero(zero));assign opcode_DDU=readdata1[31:26];assign MEMORY=PC[9:2];assign cpuclk=cont?clk_50:step;assign readaddr_reg =(choose &amp; ~mem)?DDU_addr[4:0]:rs;assign readaddr_mem=(choose &amp; mem)?DDU_addr:IorD_mux;//assign writeaddr_mem = (choose &amp; mem)?DDU_addr:ALUout[9:2];assign writeaddr_mem = ALUout[9:2];assign MDR = IorD?readdata:MDR;//扩展位操作assign sign_extend=(imm[15]&amp;(addi|PCwritecond)) ? &#123; 16'hffff,imm &#125;:&#123; 16'h0000,imm &#125;;//移位操作//assign shift_left2=(PC+(sign_extend&lt;&lt;2));assign jump_shift= &#123; PC[31:28],jump,2'b00 &#125;;//多路选择器assign IorD_mux = IorD?ALUout[9:2]:PC[9:2];assign writereg_mux = regdst?rd:rt;assign writedata_mux = memtoreg?MDR:ALUout;assign ALUsrcA_mux = A;assign data=mem?readdata:A;//assign data=readdata1;always @(posedge clk_50 or posedge rst)begin if(rst) begin inc_ctr&lt;=1; dec_ctr&lt;=1; DDU_addr&lt;=8'd0; end else begin if(inc &amp; inc_ctr) begin DDU_addr&lt;=DDU_addr+1; inc_ctr&lt;=0; end if(~inc &amp; ~inc_ctr) inc_ctr&lt;=1; if(dec &amp; dec_ctr) begin DDU_addr&lt;=DDU_addr-1; dec_ctr&lt;=0; end if(~dec &amp; ~dec_ctr) dec_ctr&lt;=1; endendalways @(posedge cpuclk)begin if(ALUsrcB==3'b000) ALUsrcB_mux=B; else if(ALUsrcB==3'b001) ALUsrcB_mux=32'd4; else if(ALUsrcB==3'b010) ALUsrcB_mux=sign_extend; else if(ALUsrcB==3'b011) ALUsrcB_mux=shift_left2;end//PCwritecond&amp;zeroalways @(current_state,PC_change,PCwritecond,zero,opcode)begin if(current_state==EX_I3) begin if(opcode==6'b000100) PC_change=PCwritecond &amp; zero ; else if(opcode==6'b000101) PC_change=PCwritecond &amp; ~zero; else PC_change=0; end else PC_change=0;endalways @(posedge cpuclk or posedge rst)begin if(rst) begin current_state=4'd1; PC&lt;=32'h0000_0000; IorD&lt;=0; end else begin case(current_state) IF: begin IorD&lt;=0; PC&lt;=PC+4; IR&lt;=readdata; memwrite1&lt;=0; current_state&lt;=ID; end ID: begin if(IR==32'h0000) current_state&lt;=IF; else begin if(opcode==6'd0) current_state&lt;=EX_R; else if(opcode==6'b100011) current_state&lt;=EX_LW; else if(opcode==6'b101011) current_state&lt;=EX_SW; else if(opcode==6'b000100 || opcode==6'b000101) current_state&lt;=EX_I3; else if(opcode==6'b000010) current_state&lt;=EX_J; else current_state&lt;=EX_I1; end end EX_R: begin current_state&lt;=MEM_R; end MEM_R: current_state&lt;=IF; EX_I1: begin current_state&lt;=MEM_I1; end MEM_I1: current_state&lt;=IF; EX_LW: begin current_state&lt;=MEM_LW; end EX_SW: begin current_state&lt;=MEM_SW; end MEM_LW: begin IorD&lt;=1; current_state&lt;=WB_LW; end WB_LW: begin IorD&lt;=0; current_state&lt;=IF; end MEM_SW: begin memwrite1&lt;=1; current_state&lt;=IF; end EX_I3: begin if(PC_change) begin shift_left2=(PC+(sign_extend&lt;&lt;2)); PC&lt;=shift_left2; end IorD&lt;=0; current_state&lt;=MEM_I3; end MEM_I3: begin current_state&lt;=IF; end EX_J: begin PC&lt;=jump_shift; IorD&lt;=0; current_state&lt;=IF; end endcase end end endmodule 仿真源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950module CPU_t( );reg cont, step, mem, inc, dec, clk, choose, rst;wire [7:0] an;wire [6:0] seg;wire [7:0] MEMORY;integer i,j;CPU cpu(.cont(cont), .step(step), .mem(mem),.inc(inc),.dec(dec),.clk_50(clk),.choose(choose),.rst(rst),.an(an),.seg(seg),.MEMORY(MEMORY));initialbeginclk=1;step=1;while(1)begin#5 clk=~clk;step=~step;endendinitialbeginrst=1;#20 rst=0;endinitialbegincont=0;mem=0;choose=0;#1000 cont=1;#1000 mem=1;choose=1;endinitialbegininc=0;dec=0;#3000for(i=0;1;i=i+1)begin#10 inc=~inc;endendendmodule","comments":true,"tags":[{"name":"multicycle_cpu","slug":"multicycle-cpu","permalink":"http://fentuoli.github.io/tags/multicycle-cpu/"},{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"},{"name":"verilog","slug":"verilog","permalink":"http://fentuoli.github.io/tags/verilog/"}]},{"title":"malloclab","date":"2020-05-05T07:13:56.000Z","path":"2020/05/05/malloclab/","text":"说明：CSAPP实验是很有名的实验，我为了完成课堂任务总共写了四个实验：bomblab、cachelab、datalab和malloclab，在做的过程中也参考了许多人的博客，其中主要参考了*码龙的窝： https://blog.codedragon.tech/about/ *，在此感谢！ 一、实验内容1. 实验内容及要求:使用显示空闲链表实现一个32位系统堆内存分配器二、实验的操作步骤及运行截图1.实现隐式空闲链表 放置策略：首次适配：从头开始搜索链表，找到第一个大小合适的空闲内存块便返回 添加宏 1234567891011121314151617181920212223242526/* Basic constants and macros */#define WSIZE 4 /* Word and header/footer size (bytes) */#define DSIZE 8 /* Double word size (bytes) */#define CHUNKSIZE (1&lt;&lt;12) /* Extend heap by this amount (bytes) */#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))/* Pack a size and allocated bit into word */#define PACK(size, alloc) ((size) | (alloc))/* Read and write a word at address p */#define GET(p) (*(unsigned int *)(p))#define PUT(p, val) (*(unsigned int *)(p) = (val))/* Read the size and allocated fields from address p */#define GET_SIZE(p) (GET(p) &amp; ~0x7)#define GET_ALLOC(p) (GET(p) &amp; 0x1)/* Given block ptr bp, compute address of its header and footer */#define HDRP(bp) ((char *)(bp) - WSIZE)#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)/* Given block ptr bp, compute address of next and previous blocks */#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) 说明： CHUNKSIZE为内存分配器扩充堆内存的最小单元。 PACK将块大小和分配位结合返回一个值（即将size的最低位赋值为分配位） GET/PUT分别对指针p指向的位置取值/赋值 GET_SIZE/GET_ALLOC分别从p指向位置获取块大小和分配位。注意：p应该指向头/脚部 HDRP/FTRP返回bp指向块的头/脚部 NEXT_BLKP/PREV_BLKP返回与bp相邻的下一/上一块 初始化分配器 12345678910111213141516171819202122232425262728293031323334353637383940414243int mm_init(void)&#123; void *bp; mem_init(); /* Create the initial empty heap */ if ((heap_listp = (char *)mem_sbrk(6*WSIZE)) == (char *)-1) return -1; starter = (unsigned int *)heap_listp + 1; PUT(heap_listp, 0); /* Alignment padding */ PUT_PREV(starter, 0); PUT_SUCC(starter, 0); /* First, starter is alone */ PUT(heap_listp + (3*WSIZE), PACK(DSIZE, 3)); /* Prologue header */ PUT(heap_listp + (4*WSIZE), PACK(DSIZE, 1)); /* Prologue footer */ PUT(heap_listp + (5*WSIZE), PACK(0, 3)); /* Epilogue header */ heap_listp += (4*WSIZE); /* Extend the empty heap with a free block of CHUNKSIZE bytes */ bp = extend_heap(CHUNKSIZE/WSIZE); if (bp == NULL) return -1; return 0;&#125;void *extend_heap(size_t words)&#123; char *bp; size_t size; /* Allocate an even number of words to maintain alignment */ size = (words % 2) ? ((words + 1) * WSIZE) : (words * WSIZE); if ((long)(bp = mem_sbrk(size)) == -1) &#123; return NULL; &#125; /* Initialize free block header/footer and the epilogue header */ PUT_NEW(HDRP(bp), PACK(size, 0)); /* Free block header */ PUT(FTRP(bp), PACK(size, 0)); /* Free block footer */ PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); /* New epilogue header */ /* Coalesce if the previous block was free */ return coalesce(bp);&#125; 分析： ​ mm_sbrk是在memblib.c中预先定义好的函数，mm_init函数首先通过sbrk请求4个字的内存(line4~5)，然后将这四个字分别作为填充块（为了对齐），序言块头/脚 部，尾块。并将heap_listp指针指向序言块使其作为链表的第一个节点(line6~10)。之后调用extend_heap函数向系 统申请一个CHUNKSIZE的内存作为堆的初始内存(line13~14)。 释放和合并块 12345678910111213141516171819202122232425262728293031323334353637383940414243void mm_free(void *ptr)&#123; size_t size = GET_SIZE(HDRP(ptr)); PUT(HDRP(ptr), PACK(size, 0)); PUT(FTRP(ptr), PACK(size, 0)); coalesce(ptr);&#125;static void *coalesce(void * bp)&#123; size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); size_t size = GET_SIZE(HDRP(bp)); if (prev_alloc &amp;&amp; next_alloc) return bp; else if (prev_alloc &amp;&amp; !next_alloc) &#123; size += GET_SIZE(HDRP(NEXT_BLKP(bp))); PUT(HDRP(bp), PACK(size, 0)); PUT(FTRP(bp), PACK(size, 0)); &#125; else if (!prev_alloc &amp;&amp; next_alloc) &#123; size += GET_SIZE(HDRP(PREV_BLKP(bp))); PUT(FTRP(bp), PACK(size, 0)); PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); bp = PREV_BLKP(bp); &#125; else &#123; size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp))); PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0)); bp = PREV_BLKP(bp); &#125; return bp;&#125; 分配块 12345678910111213141516171819202122232425void *mm_malloc(size_t size)&#123; size_t asize; size_t extendsize; char *bp; if (size == 0) return NULL; if (size &lt;= DSIZE) asize = 2 * DSIZE; else asize = DSIZE * ((size + (DSIZE) + (DSIZE-1)) / DSIZE); if ((bp = find_fit(asize)) != NULL)&#123; place(bp, asize); return bp; &#125; extendsize = MAX(asize, CHUNKSIZE); if ((bp = extend_heap(extendsize/WSIZE)) == NULL) return NULL; place(bp, asize); return bp;&#125; 自己需要实现的函数：find_fit和place find_fit: 123456789101112static void *find_fit(size_t asize)&#123; void *bp; for (bp = head_listp; GET_SIZE(HDRP(bp)) &gt; 0; bp = NEXT_BLKP(bp))&#123; if(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp)))) &#123; return bp; &#125; &#125; return NULL;&#125; 说明： ​ 用首次适配搜索。从隐式空闲链表的开头开始，寻找首个合适的未分配的块。 place: 12345678910111213141516static void place(void *bp, size_t asize)&#123; size_t csize = GET_SIZE(HDRP(bp)); if ((csize - asize) &gt;= (2*DSIZE))&#123; PUT(HDRP(bp), PACK(asize, 1)); PUT(FTRP(bp), PACK(asize, 1)); bp = NEXT_BLKP(bp); PUT(HDRP(bp), PACK(csize-asize, 0)); PUT(FTRP(bp), PACK(csize-asize, 0)); &#125; else &#123; PUT(HDRP(bp), PACK(csize, 1)); PUT(FTRP(bp), PACK(csize, 1)); &#125;&#125; 说明： 若是寻找到了合适的块，这时就要将这个块放进去。这里有两种情况，如果当前找到的块比需要填入的块大于或等于16字节，证明这个块还能够分裂成两个块，所以需要做分裂操作。不然就直接将这个整个块标记为已分配。 2.实现由双向链表组织的显式空闲链表方案 显示空闲链表是在隐式空闲链表的基础上实现的，，将堆组织成一个双向的空闲链表，在每个空闲块中，都包含一个 pred（前驱）和succ（后继）指针。对比隐式空闲链表，双向空闲链表的方式使首次适配的分配时间由块总数的线性时间减少到空闲块数量的线性时间， 因为它不需要搜索整个堆，而只是需要搜索空闲链表即可。 优化策略： 先体现在分配块没有了脚部，这可以优化空间利用率。 其次，空闲块中多了pred（前驱）和succ（后继）指针。正是由于空闲块中多了这两个指针，再加上头部、脚 部的大小，所以最小的块大小为4字。 宏定义： 12345678910#define GET_PREV(p) (*((unsigned int *)p )) /* 取出前驱信息 */#define GET_SUCC(p) (*((unsigned int *)p + 1)) /*取出后继信息*/#define PUT_PREV(p, val) (*((unsigned int *)p ) = (unsigned int)(val)) /* 设置前驱信息*/#define PUT_SUCC(p, val) (*((unsigned int *)p + 1) = (unsigned int)(val)) /*设置后继信息*//*在去除已分配块的脚时， 使分配块第1位的值表示该块前面的邻居块是否已分配，0表示前邻居未分配，1表示前邻居已分配。*/#define PUT_NEW(p,val) (*(unsigned int *)(p) = ((GET(p) &amp; 0x2 ) | (val))) /*保留块头部对于前块邻居的分配信息*/#define SET_ALLOC(bp) ((GET(HDRP(NEXT_BLKP(bp))))= GET(HDRP(NEXT_BLKP(bp))) | 0x2)/*将后块的头部的第一位设置为1*/#define SET_UNALLOC(bp) (GET(HDRP(NEXT_BLKP(bp))) &amp;=(~0x2))/*将后块的头部的第一位设置为0*/#define GET_PREV_ALLOC(bp) (GET(bp) &amp; 0x2) /*获取前块邻居是否分配的信息*/ 初始化分配器: 实现方式基本与隐式相同，只不过多分配两个块用来保存空闲链表的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 全局变量 */static unsigned int *starter = 0; int mm_init(void)&#123; void *bp; mem_init(); /* Create the initial empty heap */ if ((heap_listp = (char *)mem_sbrk(6*WSIZE)) == (char *)-1) return -1; starter = (unsigned int *)heap_listp + 1; PUT(heap_listp, 0); /* Alignment padding */ PUT_PREV(starter, 0); PUT_SUCC(starter, 0); /* First, starter is alone */ PUT(heap_listp + (3*WSIZE), PACK(DSIZE, 3)); /* Prologue header */ PUT(heap_listp + (4*WSIZE), PACK(DSIZE, 1)); /* Prologue footer */ PUT(heap_listp + (5*WSIZE), PACK(0, 3)); /* Epilogue header *//*3代表该块和前邻居块均已被分配*/ heap_listp += (4*WSIZE); /* Extend the empty heap with a free block of CHUNKSIZE bytes */ bp = extend_heap(CHUNKSIZE/WSIZE); if (bp == NULL) return -1; return 0;&#125;void *extend_heap(size_t words)&#123; char *bp; size_t size; /* Allocate an even number of words to maintain alignment */ size = (words % 2) ? ((words + 1) * WSIZE) : (words * WSIZE); if ((long)(bp = mem_sbrk(size)) == -1) &#123; return NULL; &#125; /* Initialize free block header/footer and the epilogue header */ PUT_NEW(HDRP(bp), PACK(size, 0)); /* Free block header *//*用PUT_NEW宏定义，避免头部丢失前块邻居是否分配的信息*/ PUT(FTRP(bp), PACK(size, 0)); /* Free block footer */ PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); /* New epilogue header */ /* Coalesce if the previous block was free */ return coalesce(bp);&#125; 分析：starter所在的位置为链表的头结点。 合并与释放块：在合并块时，定义了两个函数： add sub 12345/*将一个空闲块链接到相应链表的第一个*/void add(void* bp, size_t size);/*将并入的空闲块中的前驱后继指针信息去除*/void sub(void *bp); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void add(void* bp)&#123; unsigned int starter_succ_free = GET_SUCC(starter);/*获取starter后继块信息*/ PUT_PREV(bp, starter);/*将该块的前驱置为starter*/ PUT_SUCC(starter, bp);/*将starter的后继置为bp*/ PUT_SUCC(bp, starter_succ_free);/*将bp的后继置为starter的后继*/ if(starter_succ_free) PUT_PREV(starter_succ_free, bp);/*如果starter的后继非空，将starter后继的前驱置为bp*/&#125; void sub(void *bp)&#123; unsigned int succ_free, prev_free; succ_free = GET_SUCC(bp);/*获取bp前驱信息*/ prev_free = GET_PREV(bp);/*获取bp后继信息*/ PUT_SUCC(prev_free, succ_free);/*将bp的前驱的后继置为bp的后继*/ if(succ_free) PUT_PREV(succ_free, prev_free);/*如果bp的后继非空，将bp的后继的前驱置为bp的前驱*/&#125; static void *coalesce(void *bp)/* based on a explicit free list */&#123; void *next_bp = NEXT_BLKP(bp); size_t prev_alloc = GET_PREV_ALLOC(HDRP(bp)); size_t next_alloc = GET_ALLOC(HDRP(next_bp)); size_t size = GET_SIZE(HDRP(bp)); if (prev_alloc!=0 &amp;&amp; next_alloc) &#123; /* Case 1 ：前后均无空闲块*/ add(bp); &#125; else if (prev_alloc!=0 &amp;&amp; !next_alloc) &#123; /* Case 2：后块为空闲块 */ size += GET_SIZE(HDRP(next_bp)); PUT_NEW(HDRP(bp), PACK(size, 0)); /*用PUT_NEW宏定义，避免头部丢失前块邻居是否分配的信息*/ PUT(FTRP(next_bp), PACK(size,0)); sub(next_bp); add(bp); &#125; else if (!prev_alloc &amp;&amp; next_alloc) &#123; /* Case 3 ：前块为空闲块*/ void *prev_bp = PREV_BLKP(bp); size += GET_SIZE(HDRP(prev_bp)); PUT(FTRP(bp), PACK(size, 0)); PUT_NEW(HDRP(prev_bp), PACK(size, 0)); sub(prev_bp); bp = prev_bp; add(bp); &#125; else &#123; void *prev_bp = PREV_BLKP(bp); /* Case 4 ：前后块均为空闲块*/ size += GET_SIZE(HDRP(prev_bp)) + GET_SIZE(FTRP(next_bp)); PUT_NEW(HDRP(prev_bp), PACK(size, 0)); PUT(FTRP(next_bp), PACK(size, 0)); sub(next_bp); sub(prev_bp); bp = prev_bp; add(bp); &#125; return bp;&#125; void mm_free(void *ptr)&#123; size_t size = GET_SIZE(HDRP(ptr)); PUT_NEW(HDRP(ptr), PACK(size, 0)); PUT(FTRP(ptr), PACK(size, 0)); SET_UNALLOC(ptr);/*将下一个块头部的第一位置为0*/ coalesce(ptr);&#125; 寻找与放置块: 12345678910111213141516171819202122232425262728293031323334static void *find_fit(size_t asize)&#123; /* 首次适配 */ unsigned int bp; for (bp = GET_SUCC(starter); bp != 0; bp = GET_SUCC(bp)) &#123; if (asize &lt;= GET_SIZE(HDRP(bp))) return (void *)bp; &#125; return NULL; /* 无合适空闲块 */&#125;static void place(void *bp, size_t asize)&#123; size_t csize = GET_SIZE(HDRP(bp)); sub(bp); if ((csize - asize) &gt;= (2*DSIZE)) &#123; PUT_NEW(HDRP(bp), PACK(asize, 1)); SET_ALLOC(bp); /*将下一个块头部的第一位置为1*/ bp = NEXT_BLKP(bp); PUT_NEW(HDRP(bp), PACK(csize-asize, 0)); PUT(FTRP(bp), PACK(csize-asize, 0)); coalesce(bp); &#125; else&#123; PUT_NEW(HDRP(bp), PACK(csize, 1)); PUT(FTRP(bp), 0); SET_ALLOC(bp); /*将下一个块头部的第一位置为1*/ &#125;&#125; 分配块：malloc函数: 与隐式的malloc基本一致，唯一不同的地方在于显式空闲链表中分配块无脚部，故空间利用率增加了一个WSIZE。 1234567/*隐式链表中代码*/if (size &lt;= DSIZE) asize = 2 * DSIZE;/*显式链表中代码*/if (size &lt;= DSIZE+WSIZE) asize = 2 * DSIZE; 运行结果： 3.显式空闲链表：实现分离链表管理的算法 实现方法： 将空闲页面分为m个组,第1组存储20个单位的内存块，第2组存储21个单位的内存块,第3组存储22个单位的内存块，第4组存储23个单位的内存块,以此类推。直到m组。 每个组是一个链表，用于连接同等大小的内存块。 伙伴块的大小是相等的，并且第1块和第2块是伙伴，第三块和第四块是伙伴，以此类推。 宏定义：与直接用显式空闲链表实现时的宏定义相同。 初始化分配器：多分配10个块，分别用来作为保存不同大小空闲块链表的头结点，并同时定义find函数用来寻找相应的头结点位置，extend_heap函数与与直接用显式空闲链表实现时相同。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int mm_init(void)&#123; void *bp; mem_init(); /* Create the initial empty heap */ if ((heap_listp = (char *)mem_sbrk(14*WSIZE)) == (char *)-1) return -1; segregate_starter = (unsigned int *)heap_listp; PUT(heap_listp,0); /* free list, block size &lt;=16 */ PUT(heap_listp+(1*WSIZE),0); /* block size &lt;=32 */ PUT(heap_listp+(2*WSIZE),0); /* block size &lt;=64 */ PUT(heap_listp+(3*WSIZE),0); /* block size &lt;=128 */ PUT(heap_listp+(4*WSIZE),0); /* block size &lt;=256 */ PUT(heap_listp+(5*WSIZE),0); /* block size &lt;=512 */ PUT(heap_listp+(6*WSIZE),0); /* block size &lt;=1024 */ PUT(heap_listp+(7*WSIZE),0); /* block size &lt;=2048 */ PUT(heap_listp+(8*WSIZE),0); /* block size &lt;=4096 */ PUT(heap_listp+(9*WSIZE),0); /* block size &gt;4096 */ PUT(heap_listp+(10*WSIZE),0); /*双字对齐 */ PUT(heap_listp + (11*WSIZE), PACK(DSIZE, 1)); /* Prologue header */ PUT(heap_listp + (12*WSIZE), PACK(DSIZE, 1)); /* Prologue footer */ PUT(heap_listp + (13*WSIZE), PACK(0, 3)); /* Epilogue header */ heap_listp += (12*WSIZE); bp = extend_heap(2*DSIZE/WSIZE); if (bp == NULL) return -1; return 0;&#125;static void *find(size_t size)&#123; int patch = 0; if(size &lt;= 16) patch = 0; else if(size &lt;= 32) patch = 1; else if(size &lt;= 64) patch = 2; else if(size &lt;= 128) patch = 3; else if(size &lt;= 256) patch = 4; else if(size &lt;= 512) patch = 5; else if(size &lt;= 1024) patch = 6; else if(size &lt;= 2048) patch = 7; else if(size &lt;= 4096) patch = 8; else patch = 9; return segregate_starter + patch;&#125; 分析：segregate_starter所在的位置为链表的头结点。 合并与释放块：将add与sub函数进行更改，其余不变。 123456789101112131415161718192021/*将一个空闲块链接到相应链表的第一个*/void add(void* bp, size_t size)&#123; unsigned int *starter; starter = find(size); /*寻找相应链表的头结点*/ unsigned int succ_free = *starter; PUT_PREV(bp, starter); PUT_PREV(starter,bp); PUT_SUCC(bp, succ_free); if(succ_free) PUT_PREV(succ_free, bp);&#125;/*对并入的空闲块从相应链表中取出*/void sub(void *bp)&#123; unsigned int succ_free, *prev_free; succ_free = GET_SUCC(bp); prev_free = (unsigned int *)GET_PREV(bp); if((segregate_starter + 9) &gt;= prev_free) *prev_free = succ_free;/*如果该块的前驱为头结点则直接将头结点所在地址的内容置为该块的后继*/ else PUT_SUCC(prev_free, succ_free);/*否则将该块前驱的后继置为该块的后继*/ if(succ_free) PUT_PREV(succ_free, prev_free); 寻找与放置块：place函数不变，find_fit函数外部多加一重循环用来寻找头结点。 12345678910111213141516static void *find_fit(size_t asize)&#123; /* 首次适配 */ unsigned int *bp, *starter, *maxstarter = segregate_starter + 9;/*头结点的最大位置*/ for(starter = find(asize); starter &lt;= maxstarter; starter += 1) &#123; for (bp = (unsigned int *)(*starter); bp != 0; bp = (unsigned int *)GET_SUCC(bp)) &#123; if (asize &lt;= GET_SIZE(HDRP(bp))) return (void *)bp; &#125; &#125; return NULL; /* No fit */&#125; 分配块：malloc函数 与直接用显式空闲链表实现时相同。 运行结果： 对该算法进行进一步优化： 摘录一小段 trace： 1234a 0 4095a 1 4095f 0f 1 分析： ​ mm_init 函数中调用 extend_heap 函数来预分配一块 4096 字节大小的空间做为起始空闲块。但由于trace 文件中每次分配占用的空间大小在经过8字节的对齐补全计算之后， 总是大于4096, 或大于4096的整数倍。在 mm_malloc 函数当中在遇到当前空闲链表中没有合适空闲块的情况下，总是会调用 extend_heap 函数来扩展一块空闲块空间，空间的大小取4096与待分配大小中大的 那一个。 ​ 如果像 coalesce trace 文件中的这样分配，初始的 4096空间大小永远不够用，每次都要扩展，每次初始4096大小的空闲块都不能被利用起来。这样就导致了 coalesce 测试空间利用率一直都不理想。 解决方案： 修改 mm_init 函数中 extend_heap 初始扩展大小，空闲块可以 接受的最小大小是两个双字。 12bp = extend_heap(2*DSIZE/WSIZE); 运行结果： 三、出现错误及解决方案1.强制类型转换：​ 由于char 类型的指针在隐式转换为unsigned int类型的指针时会进行有符号扩展，故必须要进行显式的强制类型转换，且要想使得指针加1就能调到下一个块（每个块为4字节），必须规定指针为unsigned int*类型。 2.指针的使用：​ 在书写代码的过程中多次将p和p弄混，p为p所指向地址的值，p为地址值，使用gdb反复单步调试之后才解决了指针地址与值弄混的错误。 3.segmentation fault：​ 本次实验中除语法错误外segmentation fault几乎是唯一一个报错信息，出现segmentation fault最可能的原因是访问了空指针。 解决方案： ​ 用gdb ./mdriver 进入可执行文件进行调试，由于./mdriver不是mm的可执行文件，故进入后通过设置mm.c函数中相关函数的断点，如 b mm_iniit来调试mm函数，遇到其余.c文件的函数时直接通过n跳过该函数单步执行。当想要输出某个值时，用display+变量名或p+变量名来输出相应的值检查正误。 4.宏定义：​ 由于刚开始宏定义定义得不够规范导致出了一堆错，后来修改了宏定义仍旧由于调用不规范出了一些错。例如我刚开始定义的一个宏为： 1define GET_PREV_ALLOC(bp) (GET(HDRP(bp)) &amp; 0x2) ​ 但在调用这个宏定义时，我传入的指针也为HDRP(bp)，这就导致最终bp指向的不是该块的头部，而是上一个块的尾部，所以获取的信息不正确，一直报segmentation fault的错误。 解决方案：修改宏定义： 1define GET_PREV_ALLOC(bp) (GET(bp) &amp; 0x2) 调试之后问题成功解决。","comments":true,"tags":[{"name":"csapp","slug":"csapp","permalink":"http://fentuoli.github.io/tags/csapp/"},{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"}]},{"title":"datalab","date":"2020-05-05T07:07:08.000Z","path":"2020/05/05/datalab/","text":"说明：CSAPP实验是很有名的实验，我为了完成课堂任务总共写了四个实验：bomblab、cachelab、datalab和malloclab，在做的过程中也参考了许多人的博客，其中主要参考了*码龙的窝： https://blog.codedragon.tech/about/ *，在此感谢！ 一、实验内容及要求：​ Data Lab主要是关于位操作的实验，对应于书本的第2章：信息的表示和处理。在该实验中，学生主要需要在一个严格限制的C子集（使用优先的位运算符以及顺序结构的代码）中实现简单的逻辑，补码以及浮点数相关的函数。本实验的目的是为了让学生熟悉整数和浮点数的位级表示。 ​ 本实验的核心在于在各种受限制的条件下完成给出的15个谜题。其中包括5个位操作的谜题，7个补码运算的谜题，以及3个浮点数操作的谜题。其中每完成一个谜题都能得到一定的分数，如果使用的运算符数目小于给定的数目，还能获得加分。 二、代码实现的解释与说明： 注意事项： 0～255之间的常量（包括0和255） 函数的参数和局部变量 单目运算符 ! ~ 双目运算符 &amp; ^ | + &lt;&lt; &gt;&gt; 你将会被禁止： 使用任何的分支或者循环结构 定义或者使用任何的宏 在文件中定义任何额外函数 调用任何函数 使用任何其他的运算符 使用任何形式的类型转换 使用除了int以外的其他数据类型，这意味着你不能使用数组，结构或联合 1.位操作 bitAnd问题：要求使用~和|以及不超过8个操作符实现x&amp;y分析：使用De Morgan定律即可 1234int bitAnd(int x, int y) &#123;/* x&amp;y = ~(~(x&amp;y)) = ~(~x|~y) */ return ~(~x | ~y);&#125; getByte问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过6个操作符返回x中的第n个字节(0(LSB)&lt;=n&lt;=3(MSB))。分析：根据不同的n值将x右移不同的位数，然后使用掩码0xFF取得最低位数的字节即可。 12345int getByte(int x, int n) &#123;/* right shift in order to avoid boring arithmatic shift and try to get specific byte using bitAnd and mask. */ return ((x &gt;&gt; (n &lt;&lt; 3)) &amp; 0xFF); &#125; logicalShift问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过20个操作符实现将int值x的逻辑右移n位。分析：通过将一个全1的数通过算术右移的方式构造掩码，然后与算术右移的掩码求按位与即可。注意，直接右移32位的结果是未定义的，需要额外处理这种情况。 12345int logicalShift(int x, int n) &#123;/* try to implement logical right shift by mask and logical right shift */ int mask = ((~0) &lt;&lt; (31 + (~n + 1))) &lt;&lt; 1; return (x &gt;&gt; n) &amp; (~mask);&#125; bitCount问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过40个操作符计算一个数字x中有多少为1的位。分析：核心的思想是分治法，通过将原数字x中的位按每1,2,4…个位分组，按相邻组进行累加，最后求出结果。举例来说，假如现在有一个数395，它的二进制表示是0000000110001011(16位)，首先我们将这个数按1位分组，得到：0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1然后我们将相邻的组累加，得到：0+0 0+0 0+0 0+1 1+0 0+0 1+0 1+100 00 00 01 01 00 01 10然后我们继续将相邻的组累加，得到：00+00 00+01 01+00 01+100000 0001 0001 0011然后我们继续将相邻的组累加，得到：0000+0001 0001+001100000001 00000100最后，我们最后的两个组累加，得到：00000001+0000100=00000101结果是5，为正确答案。 12345678910int bitCount(int x) &#123;/* Divide and Conquer */ int mask = 0x55 + (0x55 &lt;&lt; 8) + (0x55 &lt;&lt; 16) + (0x55 &lt;&lt; 24); x = (x &amp; mask) + ((x &gt;&gt; 1) &amp; mask); mask = 0x33 + (0x33 &lt;&lt; 8) + (0x33 &lt;&lt; 16) + (0x33 &lt;&lt; 24); x = (x &amp; mask) + ((x &gt;&gt; 2) &amp; mask); mask = 0xF + (0xF &lt;&lt; 8) + (0xF &lt;&lt; 16) + (0xF &lt;&lt; 24); x = (x &amp; mask) + ((x &gt;&gt; 4) &amp; mask); return (x + (x &gt;&gt; 8) + (x &gt;&gt; 16) + (x &gt;&gt; 24)) &amp; 0xFF;&#125; bang问题：要求使用~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过12个操作数计算x的逻辑非。分析：逻辑非要求将0变成1，将非0的数变成0。生成0或1可以通过与掩码0x1求按位与实现，重点在于如何构造一个表达式使得0和非0的数产生不同的结果。可以考虑对于任意一个非0的数，它的负数都是从最高位到其最低位的1为止(不包括最低位的1)全部取反的结果。例如，14是00001110(8位)，而-14是11110010(8位)，为14从最高位到最低位的1(不包括这个1)，也就是000011取反，而最低位的10不变的结果。而0的负数永远是0。从这里我们可以看出，对于一个非0的数，它与它的负数按位或的结果的最高位一定会是1，而0与非0的按位或的结果的最高位永远是0。我们可以以此实现逻辑非。 1234int bang(int x) &#123;/* for x != 0, the highest bit of x | (-x) will always become 1 while when x == 0, the result is the opposite */ return (~((x | (~x + 1)) &gt;&gt; 31) &amp; 1);&#125; 2.补码运算 tmin问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过4个运算符返回以补码表示的最小的整数。分析：根据补码到整数的公式，最小的整数的补码表示为10000。 1234int tmin(void) &#123; /* TMin = 10000.... */ return (1 &lt;&lt; 31);&#125; fitsBits问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过15个操作符判断x是否能表示成n位的补码，如果是，则返回1，反之则返回0。分析：这个问题需要分正数和负数两种情况讨论，对于正数来说，如果一个数x能表示成n位的补码，那么它从最高位直到第n位一定全部为0，它的第n位一定不能为1，否则它就会变成一个负数。对于一个负数来说，如果一个数x能表示成n位的补码，那么它只需从最高位到第n位全部为1即可。因此，我们可以先将x右移n-1位，对于满足条件的正数和负数，这将产生一个全0的数或是一个全1的数。然后我们可以根据x的符号构造一个全0或者是全1的掩码。通过将这两个数按位异或并且取逻辑非，就能得到正确的结果。 1234567int fitsBits(int x, int n) &#123;/* if fitsBits then from highest bit to n bit will all become 1 - negative number or 0 - positive number * then can construct a mask to implement fitsBits with the help of ^ and ! */ return !((x &gt;&gt; (n + (~1) + 1)) ^ (((1 &lt;&lt; 31) &amp; x) &gt;&gt; 31));&#125; divpwr2问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过15个操作符求出x/(2^n)的结果，其中0&lt;=n&lt;=30。分析：对于正数，直接使用算术右移即可；对于负数，需要加上适当的偏移量以实现向上舍入，这可以用根据符号位生成1个全0或者全1的掩码来控制。 123456int divpwr2(int x, int n) &#123;/* add bias when x is negative, which is controlled by a sign-related mask */ int mask = x &gt;&gt; 31; int add = ((1 &lt;&lt; n) + (~1) + 1) &amp; mask; return (x + add) &gt;&gt; n;&#125; negate问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过5个操作符求出x的负数。分析：-x = (~x + 1) 1234int negate(int x) &#123;/* -x = (~x) + 1 */ return ~x + 1;&#125; isPositive问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过8个操作符判断x是否为正数。分析：对于正数，它的最高位一定是0，同时还要排除0的影响。 1234int isPositive(int x) &#123;/* ensure the highest bit is 0 and x != 0 */ return (!(x &gt;&gt; 31)) ^ (!(x ^ 0));&#125; isLessOrEqual问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过24个操作符判断x是否小于或等于y。分析：对于这个问题，我们需要按照是否溢出，以及x与y的符号分别讨论。最基本的思路是，做y-x，若结果的符号位为1，则返回0，反之返回1。但这样就忽略了溢出可能导致的问题，现在我们做如下考虑。若x，y均为正数，或x，y均为负数，则y-x绝不可能溢出，因此可直接用差的符号位判断大小。若x为正数，y为负数，可以直接返回0。若x为负数，y为正数，可以直接返回1。我们可以生成两种条件变量，一种为x，y同号时返回正确结果的条件变量，另一种为x，y异号时返回正确结果的条件变量。对于x，y同号和异号这两种不同的情况，我们可以用!((x ^ y) &gt;&gt; 31)生成掩码使得在任意的情况下，只有正确的条件变量生效。 12345678910int isLessOrEqual(int x, int y) &#123;/* different processing ways when x and y have the same signs or different signs */ int diff = y + (~x) + 1; int not_diff_sign = !(diff &gt;&gt; 31); int mask = !((x ^ y) &gt;&gt; 31); int result_not_overflow = mask &amp; not_diff_sign; int result_overflow = (!mask) &amp; (x &gt;&gt; 31); return result_overflow | result_not_overflow;&#125; ilog2问题：要求使用! ~ &amp; ^ | + &lt;&lt; &gt;&gt;以及不超过90个操作数求出x以2为底的对数（向下舍入），保证x&gt;0。分析：这道题核心的思想是二分查找。首先将x右移16位，如果x&gt;0，则表明结果的第5位为1，将该位置为1。然后根据结果将x右移8位（第5位为0）或者将x右移24位（第5位为1），如果x&gt;0，则表明结果的第4位为1，将该位置为1。以此类推，直到得出结果。 123456789int ilog2(int x) &#123; /* Binary Search */ int result = (!!(x &gt;&gt; 16) &lt;&lt; 4); result = result + ((!!(x &gt;&gt; (result + 8))) &lt;&lt; 3); result = result + ((!!(x &gt;&gt; (result + 4))) &lt;&lt; 2); result = result + ((!!(x &gt;&gt; (result + 2))) &lt;&lt; 1); result = result + (!!(x &gt;&gt; (result + 1))); return result;&#125; 3.浮点数操作 float_neg问题：返回对于浮点数参数f，-f的等价的位级表示。当参数为NAN时，返回NAN。函数的参数和返回值均为unsigned，但它们实际上都是浮点数的位表示。最多允许使用10个操作符。分析：首先要判断参数是否是NAN，如果是则直接返回，否的话直接将参数的最高位取反即可。NAN的阶码全为1，尾码不全为0。 12345678910unsigned float_neg(unsigned uf) &#123;/* m_flag - if m != 0 e_flag - if e == 0xff */ unsigned m_flag = 0x007fffff &amp; uf; unsigned e_flag = !(0x7f800000 &amp; (~uf)); if (e_flag &amp;&amp; m_flag) &#123; return uf; &#125; else &#123; return 0x80000000 ^ uf; &#125;&#125; float_i2f问题：返回(float)x的位级的等价表示。结果被作为unsigned int返回，但它实际上是单精度浮点数的位表示。最多允许使用30个操作符。分析：首先考虑到整数中只有0会被转换为非规格化浮点数，而其他整数会被转化为规格化浮点数。因此对于0需要做额外的处理。其次，对于负数，我们需要将其转化为正数再做处理，这就要求我们需要将x的符号保存下来，并且从补码转化为无符号表示。然后，我们需要根据转换成无符号数的x算出阶码e和尾码m。最后，我们将尾码舍入后再和阶码符号一起，生成最终的结果即可。 123456789101112131415161718192021222324unsigned float_i2f(int x) &#123;/* 1.process 0 individually 2.process negative number and store the sign 3.get the e number 4.get the m number and round it 5.construct the result */ unsigned count = 0; unsigned mask = 0x80000000; unsigned sign = x &amp; mask; unsigned c = 0, absx = x; if (x == 0) &#123; return 0; &#125; else &#123; if (x &lt; 0) &#123; absx = -x; &#125; while (!(mask &amp; absx)) &#123; count = count + 1; mask = mask &gt;&gt; 1; &#125; absx = absx &lt;&lt; (count + 1); if (((absx &amp; 0x1ff) &gt; 0x100) || ((absx &amp; 0x3ff) &gt;= 0x300)) &#123; c = 1; &#125; return sign + ((158 - count) &lt;&lt; 23) + (absx &gt;&gt; 9)+ c; &#125;&#125; float_twice问题：返回对于浮点数参数f，2*f的等价的位级表示。参数和结果都为unsigned int，但它们实际上是浮点数的位表示。当参数是NAN时，返回NAN。最多允许使用30个操作符。分析：对于非规格化浮点数，只要在保留符号位的情况下将尾码m右移一位即可，这样同时解决了尾码乘以二和进位的情况。对于规格化浮点数，只要将其阶码e加1即可。 12345678910unsigned float_twice(unsigned uf) &#123;/* denormailized number - m = m &lt;&lt; 1 normalized number - e = e + 1 */ unsigned result = uf; if ((uf &amp; 0x7f800000) == 0) &#123; result = ((uf &amp; 0x007fffff) &lt;&lt; 1) | (uf &amp; 0x80000000); &#125; else if ((uf &amp; 0x7f800000) != 0x7f800000) &#123; result = uf + 0x00800000; &#125; return result;&#125; 运行结果： 三、实验总结1.实验中遇到的一个坑​ 在运行make时出现报错：fatal error: bits/libc-header-start.h，刚开始以为是某个头文件没有包含进去，结果改了一圈仍然没有解决错误，最后在Google上搜索才发现是gcc安装环境没有安装完善导致的报错。 ​ 解决方案：输入sudoapt-get install gcc-multilib即可。","comments":true,"tags":[{"name":"csapp","slug":"csapp","permalink":"http://fentuoli.github.io/tags/csapp/"},{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"}]},{"title":"cachelab","date":"2020-05-05T06:58:22.000Z","path":"2020/05/05/cachelab/","text":"说明：CSAPP实验是很有名的实验，我为了完成课堂任务总共写了四个实验：bomblab、cachelab、datalab和malloclab，在做的过程中也参考了许多人的博客，其中主要参考了*码龙的窝： https://blog.codedragon.tech/about/ *，在此感谢！ 一、实验内容及要求：1.实验介绍：Cache Lab - Understanding Cache Memories主要是有关缓存的实验，对应于书本的第6章：存储器层次结构。主要阐明了缓存对于C语言程序的性能影响。 本实验主要分为两个部分。第一个部分要求完成一个C语言程序用来模拟缓存的行为；而第二个部分要求优化一个小的矩阵变换函数，使其具有尽可能小的缓存不命中率。 2.文件说明： csim.c：实现缓存模拟器的文件 trans.c：实现矩阵转置的文件 csim-ref：标准的缓存模拟器 csim：由你实现的模拟器可执行程序 tracegen：测试你的矩阵转置是否正确，并给出错误信息 test-trans：测试你的矩阵转置优化的如何，并给出评分 driver.py：自动进行测试 在每一次更新之后，首先用make生成文件，之后用相应的test测试即可。 二、实验操作过程及分析1.实验操作-PartA​ 在Part A中你需要在csim.c中实现一个LRU驱逐机制的缓存模拟器，该模拟器接收valgrind的trace作为输入，模拟一个缓存在该情况下的命中/不命中情况，并且输出所有的命中，不命中以及驱逐的次数。 本实验已经提供了一个用来参考的缓存模拟器csim-ref，其使用方式以及输出如下： 1234567891011121314151617181920Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;• -h: Optional help flag that prints usage info• -v: Optional verbose flag that displays trace info• -s &lt;s&gt;: Number of set index bits (S = 2 s is the number of sets)• -E &lt;E&gt;: Associativity (number of lines per set)• -b &lt;b&gt;: Number of block bits (B = 2 b is the block size)• -t &lt;tracefile&gt;: Name of the valgrind trace to replaylinux&gt; ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.tracehits:4 misses:5 evictions:3linux&gt; ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.traceL 10,1 missM 20,1 miss hitL 22,1 hitS 18,1 hitL 110,1 miss evictionL 210,1 miss evictionM 12,1 miss eviction hithits:4 misses:5 evictions:3 这样的trace文件中记载着每一次对内存的操作，前面的字母代表操作类型，统一的格式是: [空格][操作类型][空格][内存地址][逗号][大小] 其中如果第一个不是空格而是I，则代表加载，没有实际意义。 操作类型有以下三种： L：读取，从内存中读取 S：存储，向内存中存储 M：修改，这涉及一次读取，一次存储操作 然后实验给我们提供了一个程序csim-ref，我们要做的就是写出一个和它功能一样的程序。下面对实验思路进行分析： 命令行参数获取​ 由于该模拟器是命令行程序并且接受命令行参数，因此需要能对命令行参数进行解析和处理，这里直接使用getopt()函数获取相应参数即可。 数据结构​ 这是整个模拟器最基本的部分。我们需要创建合适的数据结构来模拟缓存，该数据结构不仅要能模拟缓存的数据的实际组织方式（有效位，标志位以及行和块等等），还需要考虑到LRU的驱逐机制。 文件中内存访问记录的处理和解析​ 这个是模拟器中核心的部分。模拟器的功能就是从文件中接收内存访问记录，并且根据这些记录来模拟缓存的行为，操作我们所设计的缓存的数据结构。 实验代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267/* * csim.c - A cache simulator that can replay traces from Valgrind * and output statistics such as number of hits, misses, and * evictions. The replacement policy is LRU. * * Implementation and assumptions: * 1. Each load/store can cause at most one cache miss. (I examined the trace, * the largest request I saw was for 8 bytes). * 2. Instruction loads (I) are ignored, since we are interested in evaluating * trans.c in terms of its data cache performance. * 3. data modify (M) is treated as a load followed by a store to the same * address. Hence, an M operation can result in two cache hits, or a miss and a * hit plus an possible eviction. * * The function printSummary() is given to print output. * Please use this function to print the number of hits, misses and evictions. * This is crucial for the driver to evaluate your work. */#include &lt;getopt.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;math.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include \"cachelab.h\"//#define DEBUG_ON #define ADDRESS_LENGTH 64/* Type: Memory address */typedef unsigned long long int mem_addr_t;/* Type: Cache line LRU is a counter used to implement LRU replacement policy */typedef struct cache_line &#123; char valid; mem_addr_t tag; unsigned long long int lru;&#125; cache_line_t;typedef cache_line_t* cache_set_t;typedef cache_set_t* cache_t;/* Globals set by command line args */int verbosity = 0; /* print trace if set */int s = 0; /* set index bits */int b = 0; /* block offset bits */int E = 0; /* associativity */char* trace_file = NULL;/* Derived from command line args */int S; /* number of sets */int B; /* block size (bytes) *//* Counters used to record cache statistics */int miss_count = 0;int hit_count = 0;int eviction_count = 0;unsigned long long int lru_counter = 1;/* The cache we are simulating */cache_t cache; mem_addr_t set_index_mask;/* * initCache - Allocate memory, write 0's for valid and tag and LRU * also computes the set_index_mask */void initCache()&#123; int i,j; cache = (cache_set_t*) malloc(sizeof(cache_set_t) * S); for (i=0; i&lt;S; i++)&#123; cache[i]=(cache_line_t*) malloc(sizeof(cache_line_t) * E); for (j=0; j&lt;E; j++)&#123; cache[i][j].valid = 0; cache[i][j].tag = 0; cache[i][j].lru = 0; &#125; &#125; /* Computes set index mask */ set_index_mask = (mem_addr_t) (pow(2, s) - 1);&#125;/* * freeCache - free allocated memory */void freeCache()&#123; int i; for (i=0; i&lt;S; i++)&#123; free(cache[i]); &#125; free(cache);&#125;/* * accessData - Access data at memory address addr. * If it is already in cache, increast hit_count * If it is not in cache, bring it in cache, increase miss count. * Also increase eviction_count if a line is evicted. */void accessData(mem_addr_t addr)&#123; int i; unsigned long long int eviction_lru = ULONG_MAX; unsigned int eviction_line = 0; mem_addr_t set_index = (addr &gt;&gt; b) &amp; set_index_mask; mem_addr_t tag = addr &gt;&gt; (s+b); cache_set_t cache_set = cache[set_index]; for(i=0; i&lt;E; i++)&#123; if(cache_set[i].tag==tag &amp;&amp; cache_set[i].valid)&#123; hit_count++; if(verbosity) printf(\"hit \"); cache_set[i].lru = lru_counter++; return; &#125; &#125; /* If we reach this line, then we have a cache miss */ miss_count++; if (verbosity) printf(\"miss \"); for(i=0; i&lt;E; i++)&#123; if (cache_set[i].lru &lt; eviction_lru)&#123; eviction_line = i; eviction_lru = cache_set[i].lru; &#125; &#125; if( cache_set[eviction_line].valid )&#123; eviction_count++; if (verbosity) printf(\"eviction \"); &#125; cache_set[eviction_line].valid = 1; cache_set[eviction_line].tag = tag; cache_set[eviction_line].lru = lru_counter++;&#125;/* * replayTrace - replays the given trace file against the cache */void replayTrace(char* trace_fn)&#123; char buf[1000]; mem_addr_t addr=0; unsigned int len=0; FILE* trace_fp = fopen(trace_fn, \"r\"); if(!trace_fp)&#123; fprintf(stderr, \"%s: %s\\n\", trace_fn, strerror(errno)); exit(1); &#125; while( fgets(buf, 1000, trace_fp) != NULL) &#123; if(buf[1]=='S' || buf[1]=='L' || buf[1]=='M') &#123; sscanf(buf+3, \"%llx,%u\", &amp;addr, &amp;len); if(verbosity) printf(\"%c %llx,%u \", buf[1], addr, len); accessData(addr); /* If the instruction is R/W then access again */ if(buf[1]=='M') accessData(addr); if (verbosity) printf(\"\\n\"); &#125; &#125; fclose(trace_fp);&#125;/* * printUsage - Print usage info */void printUsage(char* argv[])&#123; printf(\"Usage: %s [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\\n\", argv[0]); printf(\"Options:\\n\"); printf(\" -h Print this help message.\\n\"); printf(\" -v Optional verbose flag.\\n\"); printf(\" -s &lt;num&gt; Number of set index bits.\\n\"); printf(\" -E &lt;num&gt; Number of lines per set.\\n\"); printf(\" -b &lt;num&gt; Number of block offset bits.\\n\"); printf(\" -t &lt;file&gt; Trace file.\\n\"); printf(\"\\nExamples:\\n\"); printf(\" linux&gt; %s -s 4 -E 1 -b 4 -t traces/yi.trace\\n\", argv[0]); printf(\" linux&gt; %s -v -s 8 -E 2 -b 4 -t traces/yi.trace\\n\", argv[0]); exit(0);&#125;/* * main - Main routine */int main(int argc, char* argv[])&#123; char c; while( (c=getopt(argc,argv,\"s:E:b:t:vh\")) != -1)&#123; switch(c)&#123; case 's': s = atoi(optarg); break; case 'E': E = atoi(optarg); break; case 'b': b = atoi(optarg); break; case 't': trace_file = optarg; break; case 'v': verbosity = 1; break; case 'h': printUsage(argv); exit(0); default: printUsage(argv); exit(1); &#125; &#125; /* Make sure that all required command line args were specified */ if (s == 0 || E == 0 || b == 0 || trace_file == NULL) &#123; printf(\"%s: Missing required command line argument\\n\", argv[0]); printUsage(argv); exit(1); &#125; /* Compute S, E and B from command line args */ S = (unsigned int) pow(2, s); B = (unsigned int) pow(2, b); /* Initialize cache */ initCache();#ifdef DEBUG_ON printf(\"DEBUG: S:%u E:%u B:%u trace:%s\\n\", S, E, B, trace_file); printf(\"DEBUG: set_index_mask: %llu\\n\", set_index_mask);#endif replayTrace(trace_file); /* Free allocated memory */ freeCache(); /* Output the hit and miss statistics for the autograder */ printSummary(hit_count, miss_count, eviction_count); return 0;&#125; 运行结果： 2.实验操作-PartB在Part B中你需要在trans.c中写一个矩阵转置函数，该函数要能有尽可能少的缓存不命中(miss)数。 令A代表一个矩阵，A(i, j)代表矩阵A的第i行第j列的元素。那么，令B为矩阵A的转置，则对于A中的任意一个元素，满足A(i, j) = B(j, i)。 一个矩阵转置函数如下： 1234567891011void trans(int M, int N, int A[N][M], int B[M][N]) &#123; int i, j, tmp; for (i = 0; i &lt; N; i++) &#123; for (j = 0; j &lt; M; j++) &#123; tmp = A[i][j]; B[j][i] = tmp; &#125; &#125;&#125; 该函数是正确的，但却并不是高效的，因为其访问模式导致了相当多的缓存不命中。下面写的时候就是在这个基础上对矩阵进行优化。 首先要明确，尽管矩阵的转置本身导致对于A矩阵（原始矩阵）的读和B矩阵（转置矩阵）的写不可能同时为连续的（即不可能同时存在连续读和连续写——对A矩阵行的连续读必然导致对B矩阵列的非连续写）。但只要矩阵的大小小于缓存的总大小，那么在理想的情况下，在最初的强制不命中（即缓存为空导致的不命中）后，整个矩阵都会被加载进入缓存。在这之后的所有对于B矩阵的不连续写的引用都会命中。 在该实验中，缓存采用的是直接映射高速缓存，s = 5，b = 5，E = 1。对于该缓存，总共存在32个组，每个组共32个字节，可以装入8个int型变量，是非常有限的缓存，主要需要解决以下两个问题： 直接映射缓存所带来的冲突不命中。观察程序中矩阵存储的位置即可以发现，矩阵A和矩阵B的同一行实际上被映射到了同一个缓存组。当进行对角线的引用时，一定会发生缓存的冲突不命中。需要仔细地处理对角线上的元素。 所需优化的矩阵的总大小超出了缓存的总大小。必然导致程序的访存效率低下。 为了解决第一个问题，我们需要仔细地考虑对于矩阵元素访问的顺序。至于第二个问题，我们采用矩阵的分块技术来降低不命中数。 矩阵分块的目的在于将大的、不能完全加载进入缓存的大矩阵分块成小的、可以完全加载进入缓存的小矩阵块来处理。小矩阵块具有良好的局部性，性能显著增加。但同时也要注意，分块使得程序的可阅读性大大降低，因此一般只在常用的库函数中采用分块优化。 这里需要对三个矩阵分别操作。这三个矩阵的大小分别是：32×32 和 64×64 以及 61×67。 32 × 32矩阵优化第一部分满分的要求是300个misses以内，misses超过600则0分。 首先对矩阵进行分块处理。为了完全利用每一个缓存快（32个字节）采用8 × 8分块。然后处理对角线的问题。这里我采用的方法是无论是哪一个矩阵分块，均从该矩阵分块的对角线开始处理。同时对于A矩阵（原始矩阵）按列优先（不连续读），对于B矩阵（转置矩阵）按行优先（连续写）。 通过优先处理对角线(a, a)的元素，保证了B矩阵的第a行被载入缓存中，接下来对于A矩阵的列优先处理保证了B矩阵的第a行缓存被充分利用。 对于32 × 32的矩阵，总共存在1024次读和1024次写。对于非对角线的分块（总共12个），其缓存不命中率是1/8（仅强制不命中），对于对角线的分块（总共4个），其写的缓存不命中率是1/8（强制不命中），其读的缓存不命中率为1/4（强制不命中和冲突不命中各一半）。 因此，理论上优化之后的总缓存不命中数为2048 × 0.75 × 0.125 + 1024 × 0.25 × 0.125 + 1024 × 0.25 × 0.25 = 288次。 第一部分优化之后的代码如下： 12345678910111213for (a = 0 ; a &lt; N ; a += 8) &#123; for (b = 0 ; b &lt; M ; b += 8) &#123; for (c = b ; c &lt; b + 8 ; ++c) &#123; for (d = a + c - b ; d &gt;= a ; --d) &#123; B[c][d] = A[d][c]; &#125; for (d = a + c - b + 1 ; d &lt; a + 8 ; ++d) &#123; B[c][d] = A[d][c]; &#125; &#125; &#125;&#125; 64 × 64矩阵优化​ 第二部分的满分要求是misses小于1300，当misses大于2000则零分。 ​ 第二部分对于misses的要求限制的非常严格，同时如果采用第一部分的8 × 8分块方式会出人意料地带来大量的misses。下面具体分析8 × 8分块导致misses增多的原因。 ​ 验采用的缓存为直接映射高速缓存，s = 5， b = 5， E = 1。对于任意一个地址，其从低地址开始的第0-4位为块偏移b，第5-9为组索引s。 ​ 对于32 × 32的矩阵M来说，M[0][1]和M[1][1]之间总共间隔32个int型元素，也就是0x80个字节，也就是说，同一列相邻行的元素之间的地址间隔为0x80 = 0x100|00000。对于8 × 8的矩阵分块而言，其8行可以全部被加载进入缓存中而不发生任何冲突不命中。然而，对于64 × 64的矩阵，其同一列相邻行的元素之间的地址间隔为0x100 = 0x1000|00000。对于8 × 8的矩阵分块而言，其第1、2、3、4行的元素会和第5、6、7、8行的元素占用相同的高速缓存组，进而出现严重的冲突不命中现象。 ​ 使用4 × 4的矩阵分块又无法充分利用每一个高速缓存行（32个字节=8个int数据），仍然无法达到所要求的misses数。 ​ 经过尝试后，我使用了以下的方法进行矩阵转置的优化： ​ 仍然按照8 × 8对矩阵进行分块，只是在8 × 8的分块内部再按照4 × 4进一步分块，得到左上、右上、左下、右下4个子块。 ​ 紧接着依次按照左上、右上、右下、左下的方式处理4个子块（A矩阵）。对于左上、右下这两个可能出现对角线元素的块，按照第一个矩阵优化的方式进行处理。右上、左下子块不能简单地按照A矩阵不连续读，B矩阵连续写的方式处理。原因是对于对角线上的8 × 8分块来说，A、B矩阵的左上子块和右下子块占用了相同的高速缓存组，存在着严重的冲突不命中风险。因此对于右上、左下的子块，我们按照下图的方式处理。 ​ 图中，上方的矩阵为矩阵A，下方的矩阵为矩阵B，小方块代表矩阵的元素，黑色方块的表明加载进入临时变量/已写入的元素。红色的线表明该行被缓存。 利用8个临时变量，将左上子块的前两行加载进入临时变量中，考虑到之前的缓存条件，该次加载的缓存命中。 将一个小的2×2的矩阵转置写入矩阵B右下子块的前两行，无论是否为对角线上的分块，该次写入一定会发生缓存不命中，同时将B矩阵的前两行载入高速缓存行。 将矩阵A左上子块的后两行的2×2的矩阵加载进入空闲的4个临时变量中，同之前加载相似，该次加载的缓存命中。 将刚刚加载的2×2矩阵转置写入B矩阵右下子块前两行的剩余位置，由于之前这两行已经加载进入了高速缓存行，故该次写入的缓存全部命中。 将矩阵A后两行的剩余元素加载进入空闲的4个临时变量中，缓存命中。 将8个临时变量中的元素依次转置写入矩阵B右下子块的最后两行中，同2相似，写入一定会发生缓存不命中，同时将矩阵B的后两行载入高速缓存行。 ​ A矩阵左下子块的转置操作类似。 ​ 在A矩阵右上子块转置完成后，紧接着执行的是右下子块的转置，此时，对于非对角线上的分块而言，写入时的缓存必定命中。对于对角线上的分块，则会发生缓存不命中。 ​ 因此，对于64 × 64的矩阵，总共进行4096次读和4096次写，对于非对角线的分块（总共56个），对于A矩阵（原始矩阵而言），其左上、右下分块的不命中率为1/4，左下、右上分块的不命中率为0；对于B矩阵（转置矩阵而言），其左上、右上、左下分块的不命中率均为1/4，右下分块的不命中率为0。对于对角线上的矩阵，其B矩阵不命中率上升至1/4，对于A矩阵，其左上、右下的不命中率上升至1/2。 ​ 由此理论上优化之后的总缓存不命中数为4096 × (8/64) × (1/2 × 1/4 + 0 × 1/4 + 0 × 1/4 + 1/2 × 1/4) + 4096 × (8/64) × 1/4 + 4096 × (56/64) × (1/4 × 1/4 + 0 × 1/4 + 0 × 1/4 + 1/4 × 1/4) + 4096 × (56/64) × (1/4 × 1/4 + 1/4 × 1/4 + 0 × 1/4 + 1/4 × 1/4) = 1376次。 ​ 该优化方法对应的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788for (a = 0 ; a &lt; M ; a += 8) &#123; for (b = 0 ; b &lt; N ; b += 8) &#123; for (c = a ; c &lt; a + 4 ; ++c) &#123; for (d = b + c - a ; d &gt;= b ; -- d) &#123; B[c][d] = A[d][c]; &#125; for (d = b + c - a + 1; d &lt; b + 4 ; ++d) &#123; B[c][d] = A[d][c]; &#125; &#125; tmp0 = A[b][a + 4]; tmp1 = A[b][a + 5]; tmp2 = A[b][a + 6]; tmp3 = A[b][a + 7]; tmp4 = A[b + 1][a + 4]; tmp5 = A[b + 1][a + 5]; tmp6 = A[b + 1][a + 6]; tmp7 = A[b + 1][a + 7]; B[a + 4][b] = tmp0; B[a + 4][b + 1] = tmp4; B[a + 5][b] = tmp1; B[a + 5][b + 1] = tmp5; tmp0 = A[b + 2][a + 4]; tmp4 = A[b + 2][a + 5]; tmp1 = A[b + 3][a + 4]; tmp5 = A[b + 3][a + 5]; B[a + 4][b + 2] = tmp0; B[a + 4][b + 3] = tmp1; B[a + 5][b + 2] = tmp4; B[a + 5][b + 3] = tmp5; tmp0 = A[b + 2][a + 6]; tmp4 = A[b + 2][a + 7]; tmp1 = A[b + 3][a + 6]; tmp5 = A[b + 3][a + 7]; B[a + 6][b] = tmp2; B[a + 6][b + 1] = tmp6; B[a + 6][b + 2] = tmp0; B[a + 6][b + 3] = tmp1; B[a + 7][b] = tmp3; B[a + 7][b + 1] = tmp7; B[a + 7][b + 2] = tmp4; B[a + 7][b + 3] = tmp5; for (c = a + 4; c &lt; a + 8 ; ++c) &#123; for (d = b + c - a ; d &gt;= b + 4 ; --d) &#123; B[c][d] = A[d][c]; &#125; for (d = b + c - a + 1 ; d &lt; b + 8 ; ++d) &#123; B[c][d] = A[d][c]; &#125; &#125; tmp0 = A[b + 6][a]; tmp1 = A[b + 6][a + 1]; tmp2 = A[b + 6][a + 2]; tmp3 = A[b + 6][a + 3]; tmp4 = A[b + 7][a]; tmp5 = A[b + 7][a + 1]; tmp6 = A[b + 7][a + 2]; tmp7 = A[b + 7][a + 3]; B[a + 2][b + 6] = tmp2; B[a + 2][b + 7] = tmp6; B[a + 3][b + 6] = tmp3; B[a + 3][b + 7] = tmp7; tmp2 = A[b + 4][a + 2]; tmp3 = A[b + 4][a + 3]; tmp6 = A[b + 5][a + 2]; tmp7 = A[b + 5][a + 3]; B[a + 2][b + 4] = tmp2; B[a + 2][b + 5] = tmp6; B[a + 3][b + 4] = tmp3; B[a + 3][b + 5] = tmp7; tmp2 = A[b + 4][a]; tmp3 = A[b + 4][a + 1]; tmp6 = A[b + 5][a]; tmp7 = A[b + 5][a + 1]; B[a][b + 4] = tmp2; B[a][b + 5] = tmp6; B[a][b + 6] = tmp0;qizhongqizhong B[a][b + 7] = tmp4; B[a + 1][b + 4] = tmp3; B[a + 1][b + 5] = tmp7; B[a + 1][b + 6] = tmp1; B[a + 1][b + 7] = tmp5; &#125;&#125; ​ 实际测试的缓存不命中数是1379次。 ​ 这里注意到，虽然不允许修改矩阵A，但是矩阵B可以任意修改。因此，我们可以通过在矩阵B中暂存转置的结果来充分利用缓存，进一步降低缓存不命中数。思路如下图。 按行加载矩阵A，并且将其存入矩阵B。依次执行4次，直到整个分块的上半部分处理完毕。其中，每行的前4个元素被正确转置，后四个元素被暂存至矩阵B的右上分块。 对于分块的下半部分的第一行，先将矩阵B的右上分块的4个元素载入至临时变量，然后从矩阵A中的左下分块读取第一列并转置进入矩阵右上分块的第一行，然后将读出的4个元素存入矩阵B右下分块的第一行，最后再将矩阵A右下分块第一列转置送入矩阵B右下分块的第一行。 按照2的方式依次处理完下半部分的所有行。 ​ 对于一个8×8的分块而言，过程1处理了分块的上半部分，共执行了32次读和32次写。对于对角线上的分块，其读不命中率为1/8，写不命中率为1/4；对于非对角线上的分块，其读不命中率为1/8，写不命中率为1/8。过程2和3处理了分块的下半部分包括将矩阵B的右上子块移动到正确位置，将矩阵A的左下子块转置到B的右上子块以及矩阵A右下子块的转置，共执行了48次读和48次写。对于对角线上的分块，其读不命中率为1/3，写不命中率为1/4；对于非对角线上的分块，其读不命中率为1/12，写不命中率为1/12。 ​ 因此对于56个非对角线分块以及8个对角线分块，理论上优化后的总缓存不命中数为(32 × 1/8 + 32 × 1/8) × 56 + (32 × 1/8 + 32 × 1/4) × 8 + (48 × 1/12 + 48 × 1/12) × 56 + (48 × 1/3 + 48 × 1/4) × 8 = 1216次。 ​ 该优化方法的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243for (a = 0 ; a &lt; N ; a += 8) &#123; for (b = 0 ; b &lt; M ; b += 8) &#123; for (c = b ; c &lt; b + 4 ; ++c) &#123; tmp0 = A[c][a]; tmp1 = A[c][a + 1]; tmp2 = A[c][a + 2]; tmp3 = A[c][a + 3]; tmp4 = A[c][a + 4]; tmp5 = A[c][a + 5]; tmp6 = A[c][a + 6]; tmp7 = A[c][a + 7]; B[a][c] = tmp0; B[a + 1][c] = tmp1; B[a + 2][c] = tmp2; B[a + 3][c] = tmp3; B[a][c + 4] = tmp4; B[a + 1][c + 4] = tmp5; B[a + 2][c + 4] = tmp6; B[a + 3][c + 4] = tmp7; &#125; for (c = a + 4 ; c &lt; a + 8 ; ++c) &#123; tmp0 = B[c - 4][b + 4]; tmp1 = B[c - 4][b + 5]; tmp2 = B[c - 4][b + 6]; tmp3 = B[c - 4][b + 7]; B[c - 4][b + 4] = A[b + 4][c - 4]; B[c - 4][b + 5] = A[b + 5][c - 4]; B[c - 4][b + 6] = A[b + 6][c - 4]; B[c - 4][b + 7] = A[b + 7][c - 4]; B[c][b] = tmp0; B[c][b + 1] = tmp1; B[c][b + 2] = tmp2; B[c][b + 3] = tmp3; B[c][b + 4] = A[b + 4][c]; B[c][b + 5] = A[b + 5][c]; B[c][b + 6] = A[b + 6][c]; B[c][b + 7] = A[b + 7][c]; &#125; &#125;&#125; ​ 实际测试的缓存不命中数是1219次。 61 × 67矩阵优化​ 由于61 × 67的矩阵不是方阵，不方便定量分析。同时限制放的比较宽松，满分misses小于2000，misses大于3000零分。因此无需考虑处理对角线，仅尝试换用不同的边长分块即可。16 × 16的分块已可以保证满分。 ​ 第三部分优化之后的代码如下： 123456789or (a = 0 ; a &lt; N ; a += 16) &#123; for (b = 0 ; b &lt; M ; b += 16) &#123; for (c = b ; (c &lt; b + 16) &amp;&amp; (c &lt; M) ; ++c) &#123; for (d = a ; (d &lt; a + 16) &amp;&amp; (d &lt; N) ; ++d) &#123; B[c][d] = A[d][c]; &#125; &#125; &#125;&#125; ​ 实际测试的缓存不命中数是1847次。 运行结果： 通过./driver.py指令来对csim.c和trans.c文件进行测试：","comments":true,"tags":[{"name":"csapp","slug":"csapp","permalink":"http://fentuoli.github.io/tags/csapp/"},{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"}]},{"title":"bomblab","date":"2020-05-05T06:43:14.000Z","path":"2020/05/05/bomblab/","text":"说明：CSAPP实验是很有名的实验，我为了完成课堂任务总共写了四个实验：bomblab、cachelab、datalab和malloclab，在做的过程中也参考了许多人的博客，其中主要参考了*码龙的窝： https://blog.codedragon.tech/about/ *，在此感谢！ 一、实验内容及要求Bomb Lab主要是关于反汇编的实验，对应于书本的第三章：程序的机器级表示。 该实验给定了一个二进制程序Bomb（炸弹）。这个炸弹由若干阶段组成，每个阶段都要求你在标准输入流中输入一个字符串，如果字符串正确，那么该阶段就会被解除并且程序会进入下一个阶段。如果字符串错误，那么炸弹会爆炸，并且退出。当每个阶段都被解除后，整个炸弹将会被解除。 二、实验过程分析及截图 1.实验准备 为获得 bomb 的汇编表示，我们需要使用 objdump 工具执行一条简单的命令： 1objdump -d bomb &gt; bomb.s 观察符号表可以看到phase_1到phase_6这几个函数以及其他的相关辅助函数，我们需要给每一个阶段的函数添加断点，反汇编，并且理解这些函数的作用，并推测出答案。 2.实验过程 main函数：首先在bomb-disassemble中观察main的反汇编代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071720000000000400da0 &lt;main&gt;: 400da0: 53 push %rbx 400da1: 83 ff 01 cmp $0x1,%edi 400da4: 75 10 jne 400db6 &lt;main+0x16&gt; 400da6: 48 8b 05 9b 29 20 00 mov 0x20299b(%rip),%rax # 603748 &lt;stdin@@GLIBC_2.2.5&gt; 400dad: 48 89 05 b4 29 20 00 mov %rax,0x2029b4(%rip) # 603768 &lt;infile&gt; 400db4: eb 63 jmp 400e19 &lt;main+0x79&gt; 400db6: 48 89 f3 mov %rsi,%rbx 400db9: 83 ff 02 cmp $0x2,%edi 400dbc: 75 3a jne 400df8 &lt;main+0x58&gt; 400dbe: 48 8b 7e 08 mov 0x8(%rsi),%rdi 400dc2: be b4 22 40 00 mov $0x4022b4,%esi 400dc7: e8 44 fe ff ff callq 400c10 &lt;fopen@plt&gt; 400dcc: 48 89 05 95 29 20 00 mov %rax,0x202995(%rip) # 603768 &lt;infile&gt; 400dd3: 48 85 c0 test %rax,%rax 400dd6: 75 41 jne 400e19 &lt;main+0x79&gt; 400dd8: 48 8b 4b 08 mov 0x8(%rbx),%rcx 400ddc: 48 8b 13 mov (%rbx),%rdx 400ddf: be b6 22 40 00 mov $0x4022b6,%esi 400de4: bf 01 00 00 00 mov $0x1,%edi 400de9: e8 12 fe ff ff callq 400c00 &lt;__printf_chk@plt&gt; 400dee: bf 08 00 00 00 mov $0x8,%edi 400df3: e8 28 fe ff ff callq 400c20 &lt;exit@plt&gt; 400df8: 48 8b 16 mov (%rsi),%rdx 400dfb: be d3 22 40 00 mov $0x4022d3,%esi 400e00: bf 01 00 00 00 mov $0x1,%edi 400e05: b8 00 00 00 00 mov $0x0,%eax 400e0a: e8 f1 fd ff ff callq 400c00 &lt;__printf_chk@plt&gt; 400e0f: bf 08 00 00 00 mov $0x8,%edi 400e14: e8 07 fe ff ff callq 400c20 &lt;exit@plt&gt; 400e19: e8 84 05 00 00 callq 4013a2 &lt;initialize_bomb&gt; 400e1e: bf 38 23 40 00 mov $0x402338,%edi 400e23: e8 e8 fc ff ff callq 400b10 &lt;puts@plt&gt; 400e28: bf 78 23 40 00 mov $0x402378,%edi 400e2d: e8 de fc ff ff callq 400b10 &lt;puts@plt&gt; 400e32: e8 67 06 00 00 callq 40149e &lt;read_line&gt; 400e37: 48 89 c7 mov %rax,%rdi 400e3a: e8 a1 00 00 00 callq 400ee0 &lt;phase_1&gt; 400e3f: e8 80 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e44: bf a8 23 40 00 mov $0x4023a8,%edi 400e49: e8 c2 fc ff ff callq 400b10 &lt;puts@plt&gt; 400e4e: e8 4b 06 00 00 callq 40149e &lt;read_line&gt; 400e53: 48 89 c7 mov %rax,%rdi 400e56: e8 a1 00 00 00 callq 400efc &lt;phase_2&gt; 400e5b: e8 64 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e60: bf ed 22 40 00 mov $0x4022ed,%edi 400e65: e8 a6 fc ff ff callq 400b10 &lt;puts@plt&gt; 400e6a: e8 2f 06 00 00 callq 40149e &lt;read_line&gt; 400e6f: 48 89 c7 mov %rax,%rdi 400e72: e8 cc 00 00 00 callq 400f43 &lt;phase_3&gt; 400e77: e8 48 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e7c: bf 0b 23 40 00 mov $0x40230b,%edi 400e81: e8 8a fc ff ff callq 400b10 &lt;puts@plt&gt; 400e86: e8 13 06 00 00 callq 40149e &lt;read_line&gt; 400e8b: 48 89 c7 mov %rax,%rdi 400e8e: e8 79 01 00 00 callq 40100c &lt;phase_4&gt; 400e93: e8 2c 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e98: bf d8 23 40 00 mov $0x4023d8,%edi 400e9d: e8 6e fc ff ff callq 400b10 &lt;puts@plt&gt; 400ea2: e8 f7 05 00 00 callq 40149e &lt;read_line&gt; 400ea7: 48 89 c7 mov %rax,%rdi 400eaa: e8 b3 01 00 00 callq 401062 &lt;phase_5&gt; 400eaf: e8 10 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400eb4: bf 1a 23 40 00 mov $0x40231a,%edi 400eb9: e8 52 fc ff ff callq 400b10 &lt;puts@plt&gt; 400ebe: e8 db 05 00 00 callq 40149e &lt;read_line&gt; 400ec3: 48 89 c7 mov %rax,%rdi 400ec6: e8 29 02 00 00 callq 4010f4 &lt;phase_6&gt; 400ecb: e8 f4 06 00 00 callq 4015c4 &lt;phase_defused&gt; 400ed0: b8 00 00 00 00 mov $0x0,%eax 400ed5: 5b pop %rbx 400ed6: c3 retq 分析：结合bomb.c可以得出，main函数每次调用read_line从标准输入流中读入一行字符串，并将其返回值（即字符串的首地址）设置为第一个参数，然后依次调用phase_1到phase_6。 在每一个phase函数内部检查输入的字符串是否正确，如果不正确，则调用explode_bomb函数引爆bomb；否则则返回，返回之后由主函数再继续调用phase_defused解除该阶段。 因此，在每一个阶段中，我们关注的重点应当是phase函数内部以及phase函数所调用的其他函数。 phase_1: 在bomb-disassemble中观察phase_1的反汇编代码: 123456789100000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi #设置第二个参数为指针 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; #调用strings_not_equal函数 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; #若返回值不为0则引爆bomb 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 分析： 可以看出，phase_1调用了strings_not_equal这个函数，并为该函数配置了第二个参数0x402400，并判断该函数的返回值是否为0，如果为0则返回，否则引爆bomb。 从函数名可以推测，该函数的作用是判断两个字符串是否不相同，如果不相同，则返回非0值，相同则返回0。 还可以推测，该函数的第一个参数%rsp中存放了我们输入的字符串的首地址，而第二个参数%esi指向了待比较的字符串的首地址——也就是阶段1的答案。 所以我们使用 GDB 查看这个地址中的内容。 我们已经得到了phase_1的答案，就是”Border relations with Canada have never been better.” phase_2: 在bomb-disassemble中观察phase_2的反汇编代码: 123456789101112131415161718192021222324252627280000000000400efc &lt;phase_2&gt;: 400efc: 55 push %rbp 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp 400f02: 48 89 e6 mov %rsp,%rsi 400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt; #从输入的字符串中读入6个数字 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt; 400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt; #如果第一个数字不为1则引爆炸弹 400f15: eb 19 jmp 400f30 &lt;phase_2+0x34&gt; 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax # 计算前一个元素*2 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt; 400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt; #若当前元素不等于前一个元素*2则引爆bomb 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt; # 指向下一个元素 400f2e: eb 0c jmp 400f3c &lt;phase_2+0x40&gt; 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp #设置b和bEnd 400f3a: eb db jmp 400f17 &lt;phase_2+0x1b&gt; 400f3c: 48 83 c4 28 add $0x28,%rsp 400f40: 5b pop %rbx 400f41: 5d pop %rbp 400f42: c3 retq 可以看出，在phase_2的一开始调用了read_six_numbers这个函数，初步推测这是用来从输入字符串中读取六个数字的函数，其将输入字符串的地址作为第一个参数，将栈顶指针%rsp作为第二个参数，下面我们查看read_six_numbers的反汇编代码: 1234567891011121314151617181920000000000040145c &lt;read_six_numbers&gt;: 40145c: 48 83 ec 18 sub $0x18,%rsp 401460: 48 89 f2 mov %rsi,%rdx 401463: 48 8d 4e 04 lea 0x4(%rsi),%rcx 401467: 48 8d 46 14 lea 0x14(%rsi),%rax 40146b: 48 89 44 24 08 mov %rax,0x8(%rsp) 401470: 48 8d 46 10 lea 0x10(%rsi),%rax 401474: 48 89 04 24 mov %rax,(%rsp) 401478: 4c 8d 4e 0c lea 0xc(%rsi),%r9 40147c: 4c 8d 46 08 lea 0x8(%rsi),%r8 401480: be c3 25 40 00 mov $0x4025c3,%esi 401485: b8 00 00 00 00 mov $0x0,%eax # 为sscanf配置参数 40148a: e8 61 f7 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; # 调用sscanf(input, \"%d %d %d %d %d %d\", &amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3], &amp;a[4], &amp;a[5]); 40148f: 83 f8 05 cmp $0x5,%eax 401492: 7f 05 jg 401499 &lt;read_six_numbers+0x3d&gt; 401494: e8 a1 ff ff ff callq 40143a &lt;explode_bomb&gt; #若读取成功的数字数小于6则引爆bomb 401499: 48 83 c4 18 add $0x18,%rsp 40149d: c3 retq 可以看出，该函数在0x401460-0x401480为函数的调用构造了参数，在0x401485将返回值置0，并在0x40148a处调用了sscanf函数。并且检查sscanf函数的返回值（读取成功的变量个数），如果返回值&lt;=5，则引爆bomb，否则则正确返回。 下面我们重点观察调用函数的参数构造过程。%rdi是第1个参数，指向了输入的字符串，推测第2个参数%rsi应该指向了格式化字符串的首地址，且该字符串为”%d %d %d %d %d %d”。%rdx是第3个参数，为%rsi+0，%rcx是第4个参数，为%rsi+4，%r8是第5个参数，为%rsi+8，%r9是第6个参数，为%rsi+12。(%rsp)是第7个参数，为%rsi+16，(%rsp+8)是第8个参数，为%rsi+20。 可以归纳出read_six_numbers接收2个参数，其中第1个参数为输入字符串的首地址，第2个参数为6元素的int型数组的首地址，该函数从输入字符串中读取6个数字，并且将这6个数字存入第2个参数所指向的int型数组中。但如果读取的数字不足6个，则会引爆bomb。 然后我们回到phase_2函数中，将phase_2函数逆向，可以得到如下的结果： 123456789101112void phase_2(char * input) &#123; int a[6]; read_six_numbers(input, a); if (a[0] == 1) explode_bomb(); int * b = &amp;a[1], * bEnd = &amp;a[6]; do &#123; int val = (*(b-1)) * 2; if (*b != val) explode_bomb(); b++; &#125; while (b != bEnd); return;&#125; 上述代码依次检查了读入的6个数字，第1个数字必须为1，从第2个数字开始，每一个数字都必须是上一个数字的两倍，否则将会引爆bomb。显然，phase_2的答案为”1 2 4 8 16 32”。 phase_3: 在bomb-disassemble中观察phase_3的反汇编代码: 123456789101112131415161718192021222324252627282930313233343536370000000000400f43 &lt;phase_3&gt;: 400f43: sub $0x18,%rsp 400f47: lea 0xc(%rsp),%rcx 400f4c: lea 0x8(%rsp),%rdx 400f51: mov $0x4025cf,%esi # 又是一个字符串，可以用 gdb 查看，得到`\"%d %d\", 格式化字符串，说明输入两个数字 400f56: mov $0x0,%eax 400f5b: callq 400bf0 &lt;__isoc99_sscanf@plt&gt; # 输入 400f60: cmp $0x1,%eax # 判断输入成功 400f63: jg 400f6a &lt;phase_3+0x27&gt; 400f65: callq 40143a &lt;explode_bomb&gt; 400f6a: cmpl $0x7,0x8(%rsp) # 第一个参数是否小于等于 7, 大于则 boom 400f6f: ja 400fad &lt;phase_3+0x6a&gt; 400f71: mov 0x8(%rsp),%eax 400f75: jmpq *0x402470(,%rax,8) # 以下是 switch, 根据 rax, 即第一个输入的参数跳转 400f7c: mov $0xcf,%eax # 由此容易得到答案，比如这里是 rax=0 时，则 另一个参数为 0xcf = 207 400f81: jmp 400fbe &lt;phase_3+0x7b&gt; 400f83: mov $0x2c3,%eax 400f88: jmp 400fbe &lt;phase_3+0x7b&gt; 400f8a: mov $0x100,%eax 400f8f: jmp 400fbe &lt;phase_3+0x7b&gt; 400f91: mov $0x185,%eax 400f96: jmp 400fbe &lt;phase_3+0x7b&gt; 400f98: mov $0xce,%eax 400f9d: jmp 400fbe &lt;phase_3+0x7b&gt; 400f9f: mov $0x2aa,%eax 400fa4: jmp 400fbe &lt;phase_3+0x7b&gt; 400fa6: mov $0x147,%eax 400fab: jmp 400fbe &lt;phase_3+0x7b&gt; 400fad: callq 40143a &lt;explode_bomb&gt; 400fb2: mov $0x0,%eax 400fb7: jmp 400fbe &lt;phase_3+0x7b&gt; 400fb9: mov $0x137,%eax 400fbe: cmp 0xc(%rsp),%eax 400fc2: je 400fc9 &lt;phase_3+0x86&gt; 400fc4: callq 40143a &lt;explode_bomb&gt; 400fc9: add $0x18,%rsp 400fcd: retq 推测phase_3的一开始用sscanf从输入字符串中读入了2个int型数字。 然后观察phase_3中的jmpq ×0x402470(,%rax,8)以及下面的mov与jmp指令，基本上可以肯定这是使用跳转表实现的switch语句。 下面在GDB中验证并记录不同%rax的值对应跳转表的不同跳转位置。 从GDB运行的结果可以看出，sscanf确实读入了两个int *数字，并且也得到了所有的%rax对应的跳转表的不同跳转位置。 将phase_3函数逆向，得到如下的结果： 12345678910111213141516171819void phase_3(char * input) &#123; int a, b; int val = sscanf(input, \"%d %d\", &amp;a, &amp;b); if (val &lt;= 1) explode_bomb(); switch (a) &#123; case 0: a = 207; break; case 1: a = 311; break; case 2: a = 707; break; case 3: a = 256; break; case 4: a = 389; break; case 5: a = 206; break; case 6: a = 682; break; case 7: a = 327; break; default: explode_bomb(); a = 0; break; &#125; if (a != b) explode_bomb(); return;&#125; 根据逆向的结果，我们可以得知，本阶段要求输入2个数，且第1个数只能为0到7，且根据第1个数取值的不同，满足条件的第2个数的取值也不同,可得跳转表如下：%rax 跳转地址 0xc(%rsp)0 0x0000000000400f7c 0xcf 2071 0x0000000000400fb9 0x137 3112 0x0000000000400f83 0x2c3 7073 0x0000000000400f8a 0x100 2564 0x0000000000400f91 0x185 3895 0x0000000000400f98 0xce 2066 0x0000000000400f9f 0x2aa 6827 0x0000000000400fa6 0x147 327 phase_4: 在bomb-disassemble中观察phase_4的反汇编代码: 123456789101112131415161718192021222324000000000040100c &lt;phase_4&gt;: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; # 从输入的字符串中读取两个数字 并存入局部变量中 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 &lt;phase_4+0x29&gt; # 若数字不为两个 则引爆bomb 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a &lt;phase_4+0x2e&gt; # 若第一个数字大于14 则引爆bomb 401035: e8 00 04 00 00 callq 40143a &lt;explode_bomb&gt; 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce &lt;func4&gt; # 调用func4 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 &lt;phase_4+0x4c&gt; 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) 401056: 74 05 je 40105d &lt;phase_4+0x51&gt; # 当返回值和b均为0时 解除阶段 否则 引爆bomb 401058: e8 dd 03 00 00 callq 40143a &lt;explode_bomb&gt; 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 可以注意到，phase_4的反汇编代码前半部分与phase_3相似，均是从输入的字符串中读入2个数字。 将phase_4逆向，得到如下的结果： 12345678void phase_4(char * input) &#123; int a, b; int val = sscanf(input, \"%d %d\", &amp;a, &amp;b); if (val != 2 || ((unsigned)a &gt; 14)) explode_bomb(); val = func4(a, 0, 14); if (val != 0 || b != 0) explode_bomb(); return; 从逆向的结果我们可以看出，phase_4从输入的字符串中读入2个数字a和b，并且a必须小于等于14且大于等于0，然后phase_4调用func4(a, 0, 14)，且只有该函数的返回值和b均为0时，该阶段解除。 下面查看func4的反汇编代码： 12345678910111213141516171819202122232425262728290000000000400fce &lt;func4&gt;: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax # 实际上是/2过程，为了保证负数时舍入正确才使用了位移 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx # %rax加上b 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; # if分支 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; # 递归过程 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; # 递归过程 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 观察反汇编的func4函数，发现func4函数中调用了func4函数自身，由此可以推测func4函数是一个递归过程。 将func4逆向，得到如下的结果： 12345678910int func4(int a, int b, int c) &#123; int returnVal = (c - b) / 2; int val = returnVal + b; if (val == a) return 0; if (val &lt; a) &#123; return 2 * func4(a, val + 1, c) + 1; &#125; else &#123; return 2 * func4(a, b, val - 1); &#125;&#125; 观察func4的逆向结果，我们可以发现func4非常类似于二分查找的过程。要另func4的返回值为0，则一定不能让func4执行val&lt;a的分支即必须一直保证(b+c)/2 &gt;= a。考虑到0&lt;=a&lt;=14，所以满足条件的a有a=7 a=3 a=1 a=0 共4个。 phase_5: 在bomb-disassemble中观察phase_5的反汇编代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950510000000000401062 &lt;phase_5&gt;: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 # 栈破坏检测机制 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 401078: 31 c0 xor %eax,%eax 40107a: e8 9c 02 00 00 callq 40131b &lt;string_length&gt; # 计算输入字符串长度 40107f: 83 f8 06 cmp $0x6,%eax 401082: 74 4e je 4010d2 &lt;phase_5+0x70&gt; # 若长度不为6 则引爆bomb 401084: e8 b1 03 00 00 callq 40143a &lt;explode_bomb&gt; 401089: eb 47 jmp 4010d2 &lt;phase_5+0x70&gt; 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 实际上是a[i] = 0x4024b0[input[i] &amp; 0xf] 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; # 循环以及条件判断 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) # 为构造的字符串尾部加上'\\0' 4010b3: be 5e 24 40 00 mov $0x40245e,%esi 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt; # 调用strings_not_equal函数 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 &lt;phase_5+0x77&gt; # 若返回值不为0 则引爆bomb 4010c6: e8 6f 03 00 00 callq 40143a &lt;explode_bomb&gt; 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0: eb 07 jmp 4010d9 &lt;phase_5+0x77&gt; 4010d2: b8 00 00 00 00 mov $0x0,%eax 4010d7: eb b2 jmp 40108b &lt;phase_5+0x29&gt; 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5: 00 00 4010e7: 74 05 je 4010ee &lt;phase_5+0x8c&gt; 4010e9: e8 42 fa ff ff callq 400b30 &lt;__stack_chk_fail@plt&gt; 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq 首先，我们注意到phase_5采用了栈破坏检测机制，并且设置了相应的哨兵值防止栈缓冲区溢出。然后我们将phase_5逆向，得到如下的结果： 12345678910void phase_5(char * input) &#123; char a[7]; if (strlen(input) != 6) explode_bomb(); for (int i = 0 ; i &lt; 6 ; i++) a[i] = 0x4024b0[input[i] &amp; 0xf]; a[6] = '\\0'; int val = strings_not_equal(a, 0x40245e); if (val != 0) explode_bomb(); return; 在GDB中打印0x4024b0和0x40245e所对应的字符串，命令和结果如下所示： 在有了目标字符串后，我们现在知道了上述的字符串可以看做是一张查找表，可以得到对应关系： 0123456789abcdefmaduiersnfotvbyl 所以，我们要得到 “flyers”，就应该输入“9 f e 5 6 7”，将数字对应到 ASCII 码中的字符，可以得到“INOEFG”。 phase_6: 关卡 6 需要仔细分析，我使用了 GDB 单步运行的方法来分析了运行过程。首先，函数要求读入 6 个数，并确认个数是否为 6。 12345678910111213141516171800000000004010f4 &lt;phase_6&gt;: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c &lt;read_six_numbers&gt; 40110b: 49 89 e6 mov %rsp,%r14 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d 401114: 4c 89 ed mov %r13,%rbp 401117: 41 8b 45 00 mov 0x0(%r13),%eax 40111b: 83 e8 01 sub $0x1,%eax 40111e: 83 f8 05 cmp $0x5,%eax 401121: 76 05 jbe 401128 &lt;phase_6+0x34&gt; 401123: e8 12 03 00 00 callq 40143a &lt;explode_bomb&gt; 然后，通过双重循环，判断 6 个数之间不存在重复。 123456789101112131415161718192021222324401138: 8b 04 84 mov (%rsp,%rax,4),%eax40113b: 39 45 00 cmp %eax,0x0(%rbp)40113e: 75 05 jne 401145 &lt;phase_6+0x51&gt;401140: e8 f5 02 00 00 callq 40143a &lt;explode_bomb&gt;401145: 83 c3 01 add $0x1,%ebx401148: 83 fb 05 cmp $0x5,%ebx40114b: 7e e8 jle 401135 &lt;phase_6+0x41&gt;40114d: 49 83 c5 04 add $0x4,%r13401151: eb c1 jmp 401114 &lt;phase_6+0x20&gt;401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi401158: 4c 89 f0 mov %r14,%rax40115b: b9 07 00 00 00 mov $0x7,%ecx401160: 89 ca mov %ecx,%edx401162: 2b 10 sub (%rax),%edx401164: 89 10 mov %edx,(%rax)401166: 48 83 c0 04 add $0x4,%rax40116a: 48 39 f0 cmp %rsi,%rax40116d: 75 f1 jne 401160 &lt;phase_6+0x6c&gt;40116f: be 00 00 00 00 mov $0x0,%esi401174: eb 21 jmp 401197 &lt;phase_6+0xa3&gt;401176: 48 8b 52 08 mov 0x8(%rdx),%rdx40117a: 83 c0 01 add $0x1,%eax40117d: 39 c8 cmp %ecx,%eax40117f: 75 f5 jne 401176 &lt;phase_6+0x82&gt; 这里有一个要细节，就是这段代码保存了和 7 的差： 1234401158: 4c 89 f0 mov %r14,%rax40115b: b9 07 00 00 00 mov $0x7,%ecx401160: 89 ca mov %ecx,%edx 接下来的代码中，有一个奇怪的地址，我们打印它的内容： 通过分析这个结构，我们可以看到它是一个链表，定义类似于: 123456struct Node &#123; int value; int index; struct node *next;&#125; 接下来，代码要求由大到小获取链表中的值： 所以我们打印链表的节点值： 从大到小排列他们的索引分别是：3 4 5 6 1 2，考虑被 7 减的操作，所以答案是：4 3 2 1 6 5 ![6]/bomblab/6.PNG) 隐藏关卡 隐藏关卡的入口在 phase_defused 中，所以，我们在函数入口设置断点，研究怎样才能进入secret_phase。phase_defused 的开头统计了我们目前输入了多少个答案，如果不为 6，那么你永远都无法触发隐藏关卡。 12345678900000000004015c4 &lt;phase_defused&gt;: 4015c4: 48 83 ec 78 sub $0x78,%rsp 4015c8: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf: 00 00 4015d1: 48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6: 31 c0 xor %eax,%eax 4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 &lt;num_input_strings&gt; 4015df: 75 5e jne 40163f &lt;phase_defused+0x7b&gt; 接下来，我们分析触发 secret_phase 的代码： 123456789101112131415161718194015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r84015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx4015f0: be 19 26 40 00 mov $0x402619,%esi4015f5: bf 70 38 60 00 mov $0x603870,%edi4015fa: e8 f1 f5 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt;4015ff: 83 f8 03 cmp $0x3,%eax401602: 75 31 jne 401635 &lt;phase_defused+0x71&gt;401604: be 22 26 40 00 mov $0x402622,%esi401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi40160e: e8 25 fd ff ff callq 401338 &lt;strings_not_equal&gt;401613: 85 c0 test %eax,%eax401615: 75 1e jne 401635 &lt;phase_defused+0x71&gt;401617: bf f8 24 40 00 mov $0x4024f8,%edi40161c: e8 ef f4 ff ff callq 400b10 &lt;puts@plt&gt;401621: bf 20 25 40 00 mov $0x402520,%edi401626: e8 e5 f4 ff ff callq 400b10 &lt;puts@plt&gt;40162b: b8 00 00 00 00 mov $0x0,%eax401630: e8 0d fc ff ff callq 401242 &lt;secret_phase&gt; 首先程序将三个值保存在寄存器，我们查看它们的内容： 分别是7、4、3。 下面是两个特殊的地址，并且将地址指向的值作为了 sscanf 的参数。我们打印这两个特殊地址的值： 现在我们可以看到，sscanf 要求的输入格式是两个整数和一个字符串，而其中的两个整数是我们在关卡 4输入的值，那么剩下的字符串应该是什么呢？ 我们可以看到，剩余的代码中还有一系列地址，我们打印他们指向的内存中的值： 可以看到最后一个就是我们想要的字符串。我们把它加到关卡 4 的答案后面即可进入隐藏关卡。 接下来我们查看隐藏关卡的代码： 1234567891011121314151617181920212223240000000000401242 &lt;secret_phase&gt;: 401242: 53 push %rbx 401243: e8 56 02 00 00 callq 40149e &lt;read_line&gt; 401248: ba 0a 00 00 00 mov $0xa,%edx 40124d: be 00 00 00 00 mov $0x0,%esi 401252: 48 89 c7 mov %rax,%rdi 401255: e8 76 f9 ff ff callq 400bd0 &lt;strtol@plt&gt; 40125a: 48 89 c3 mov %rax,%rbx 40125d: 8d 40 ff lea -0x1(%rax),%eax 401260: 3d e8 03 00 00 cmp $0x3e8,%eax 401265: 76 05 jbe 40126c &lt;secret_phase+0x2a&gt; 401267: e8 ce 01 00 00 callq 40143a &lt;explode_bomb&gt; 40126c: 89 de mov %ebx,%esi 40126e: bf f0 30 60 00 mov $0x6030f0,%edi 401273: e8 8c ff ff ff callq 401204 &lt;fun7&gt; 401278: 83 f8 02 cmp $0x2,%eax 40127b: 74 05 je 401282 &lt;secret_phase+0x40&gt; 40127d: e8 b8 01 00 00 callq 40143a &lt;explode_bomb&gt; 401282: bf 38 24 40 00 mov $0x402438,%edi 401287: e8 84 f8 ff ff callq 400b10 &lt;puts@plt&gt; 40128c: e8 33 03 00 00 callq 4015c4 &lt;phase_defused&gt; 401291: 5b pop %rbx 401292: c3 retq 代码首先读入一个字符串，然后调用 strtol 将它转换成 10 进制数，并和 0x3e8（也就是 1000）比较，如果大于1000，则引爆；否则，调用 fun7，fun7的参数是一个地址和一个数。如果 fun7 的返回值等于 2，则拆弹成功。 下面是fun7的汇编代码： 123456789101112131415161718192021220000000000401204 &lt;fun7&gt;: 401204: 48 83 ec 08 sub $0x8,%rsp 401208: 48 85 ff test %rdi,%rdi 40120b: 74 2b je 401238 &lt;fun7+0x34&gt; 40120d: 8b 17 mov (%rdi),%edx 40120f: 39 f2 cmp %esi,%edx 401211: 7e 0d jle 401220 &lt;fun7+0x1c&gt; 401213: 48 8b 7f 08 mov 0x8(%rdi),%rdi 401217: e8 e8 ff ff ff callq 401204 &lt;fun7&gt; 40121c: 01 c0 add %eax,%eax 40121e: eb 1d jmp 40123d &lt;fun7+0x39&gt; 401220: b8 00 00 00 00 mov $0x0,%eax 401225: 39 f2 cmp %esi,%edx 401227: 74 14 je 40123d &lt;fun7+0x39&gt; 401229: 48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d: e8 d2 ff ff ff callq 401204 &lt;fun7&gt; 401232: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236: eb 05 jmp 40123d &lt;fun7+0x39&gt; 401238: b8 ff ff ff ff mov $0xffffffff,%eax 40123d: 48 83 c4 08 add $0x8,%rsp 401241: c3 retq fun7 是一个递归函数，它的 C 语言版本为： 1234567891011121314// %rdi 为 &amp;x, %esi 为 yint fun7(int *x, int y) &#123; if (x == NULL) return -1; int ret = 0; if (*x &lt; y) &#123; ret = fun7(x + 0x10, y); ret = ret * 2 + 1; &#125; else if (*x == y) &#123; return 0; &#125; else &#123; ret = fun7(x + 0x8, y); ret *= 2; &#125; 为了让 fun7 返回 2，需要递归三层： 12342 = 2 11 = 2 0 + 10 = 0 我们让 0x6030f0 + 0x08 + 0x10 = 0x603108，访问这个地址，我们得到 0x16（十进制为 22）。","comments":true,"tags":[{"name":"csapp","slug":"csapp","permalink":"http://fentuoli.github.io/tags/csapp/"},{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"}]},{"title":"FAT文件系统的实现","date":"2020-05-05T06:07:11.000Z","path":"2020/05/05/OS实验/","text":"本实验是操作系统课程的要求实验，大致为实现一个FAT文件系统，具体要求和完整代码请参见我的github地址： https://github.com/fentuoli/FAT-file-system 一、实验内容及要求​ 熟悉FAT16的存储结构，利用FUSE实现一个只读的FAT文件系统 。 二、实验准备工作1.熟悉使用FUSE 配置FUSE环境 123456wget -O libfuse-2.9.5.zip https://codeload.github.com/libfuse/libfuse/zip/fuse_2_9_5 unzip libfuse-2.9.5.zip cd libfuse-fuse_2_9_5/ ./makeconf.sh ./configure --prefix=/usr make -j4 sudo make install 编译出错处理 12sudo apt install libtool sudo apt install autoconf 测试FUSE 123cd example mkdir fuse_test_dir ./fusexmp -d fuse_test_dir 用Ctrl+C结束程序。 2.FAT文件系统 FAT格式磁盘镜像的制作过程 1234dd if=/dev/zero of=fat-disk.img bs=1M count=100mkfs.vfat -F 16 fat-disk.imgmkdir mdir mount fat-disk.img mdir FAT16的存储结构 FAT16文件系统的基本结构依次为：DBR扇区、FAT表1、FAT表2、根目录和数据区，FAT16格式的磁盘的组织 方式如下图所示： DBR扇区：由于lab4.pdf上所给的DBR扇区内容表格不够完整，所以我又自行检索了一个更加完整的表格 我们可以根据上述的BPB的字段计算FAT系统的各个部分的偏移地址和大小。 12FatStartSector = BPB_ResvSecCnt;FatSectors = BPB_FATSz * BPB_NumFATs; 根目录区的偏移地址和大小可以计算如下，计算根目录扇区数量时乘以的32是指目录中的一条记录长度为32个字节。 加上BPB_BytsPerSec再减去1是为了做除法运算时向上取整的。 12RootDirStartSector = FatStartSector + FatSectors;RootDirSectors = (32 * BPB_RootEntCnt + BPB_BytsPerSec - 1) / BPB_BytsPerSec; 根目录区之后就是数据区，用于记录实际的文件和目录内容的区域。我们可以通过如下的语句计算数据区的偏移地址和大小。 12DataStartSector = RootDirStartSector + RootDirSectors;DataSectors = BPB_TotSec - DataStartSector; FAT表： 根目录：：FAT文件系统的一个重要思想是把目录当作一个特殊文件来处理，在FAT16中，虽然根目录地位并不等 同于普通的目录，但其组织形式和普通的目录并没有不同。不管目录文件所占空间为多少簇，系统都会以32个 字节为单位进行目录文件所占簇的分配。每个32字节目录项表示的具体含义如下： FAT表与文件定位： ​ FAT16文件系统从根目录所占的32个扇区之后的第一个扇区开始以簇为单位进行数据的处 理，这之前仍以扇区为单位。对于根目录之后的第一个簇，系统并不编号为0号簇或1号簇，而是编号为2号簇， 也就是说数据区顺序上的第1个簇也是编号上的2号簇。 ​ 假设一个文件，其首簇号是2，则查看FAT的相对偏移0x4~0x5的内容，此处为0xFFFF，表示存储在2号簇上的文 件是个小文件，只占用1个簇便结束了。 假设另一个文件的首簇号是8，则查看FAT的相对偏移0x10-0x11的内容，为0x0009，就是说该文件继8号簇后 的内容会存放在9号簇中；继续查看9号簇的FAT表项内容是0x000A，该文件继9簇后的内容会存放在10号簇 中，继续这个过程，会发现文件在11号簇结束。 三、实验操作过程1.TODO 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** TODO: * 将输入路径按“/”分割成多个字符串，并按照FAT文件名格式转换字符串 * * Hint1:假设pathInput为“/dir1/dir2/file.txt”，则将其分割成“dir1”，“dir2”，“file.txt”， * 每个字符串转换成长度为11的FAT格式的文件名，如“file.txt”转换成“FILE TXT”， * 返回转换后的字符串数组，并将*pathDepth_ret设置为3 * Hint2:可能会出现过长的字符串输入，如“/.Trash-1000”，需要自行截断字符串**/char **path_split(char *pathInput, int *pathDepth_ret)&#123; int pathDepth = 1; char **pathchange = malloc(pathDepth * sizeof(char *)); int len,i,j,k,pathnum=0,m=0,n=0; len=strlen(pathInput); for(i=0;i&lt;len;i++)&#123; if(pathInput[i]!='/') continue; else pathnum++; &#125; *pathDepth_ret=pathnum; pathDepth=pathnum; for(i=0;i&lt;pathnum;i++) pathchange[i]=(char *)malloc(MAX_SHORT_NAME_LEN *sizeof(char));//pathchange中存储最终转换为FAT格式的路径 char pathdiv[pathnum][30],a[pathnum][30],b[pathnum][30];//pathdiv中存储按'/'进行分割的路径 for(i=1;i&lt;len;i++)&#123; if(pathInput[i]!='/')&#123; pathdiv[m][n]=pathInput[i]; n++; &#125; else&#123; pathdiv[m][n]='\\0'; m++; n=0; &#125; &#125; pathdiv[m][n]='\\0'; for(i=0;i&lt;pathnum;i++)&#123; k=0; for(j=0;j&lt;strlen(pathdiv[i]);j++)&#123; b[i][0]='\\0'; if(pathdiv[i][j]!='.') a[i][j]=pathdiv[i][j]; //a中存储'.'之前的字符串 else&#123; a[i][j]='\\0'; j++; for(k=j;k&lt;strlen(pathdiv[i]);k++)&#123; b[i][k-j]=pathdiv[i][k]; &#125; b[i][k-j]='\\0';//b中存储'.'之后的字符串 break; &#125; &#125; a[i][j]='\\0'; if(strlen(a[i])&lt;8)&#123; for(j=0;j&lt;strlen(a[i]);j++)&#123; if(a[i][j]&gt;='a' &amp;&amp; a[i][j]&lt;='z') pathchange[i][j]=toupper(a[i][j]);//toupper函数将小写字母转换为大写字母 else pathchange[i][j]=a[i][j];//非小写字母的字符保存不变 &#125; for(k=j;k&lt;8;k++) pathchange[i][k]=' ';//补空格 &#125; else&#123; for(j=0;j&lt;8;j++)&#123; if(a[i][j]&gt;='a' &amp;&amp; a[i][j]&lt;='z') pathchange[i][j]=toupper(a[i][j]); else pathchange[i][j]=a[i][j]; &#125; &#125; if(strlen(b[i])&lt;3)&#123; for(j=0;j&lt;strlen(b[i]);j++)&#123; if(b[i][j]&gt;='a' &amp;&amp; b[i][j]&lt;='z') pathchange[i][8+j]=toupper(b[i][j]); else pathchange[i][8+j]=b[i][j]; &#125; for(k=j;k&lt;3;k++) pathchange[i][k+8]=' '; &#125; else&#123; for(j=0;j&lt;3;j++)&#123; if(b[i][j]&gt;='a' &amp;&amp; b[i][j]&lt;='z') pathchange[i][8+j]=toupper(b[i][j]); else pathchange[i][8+j]=b[i][j]; &#125; &#125; &#125; for(i=0;i&lt;pathnum;i++)&#123; pathchange[i][11]='\\0'; &#125; return pathchange;&#125; 说明：**path_split函数的功能就是将输入路径按’’/‘’进行分割，并将每一级目录按’’.’’进行划分，’’.’’之前的字符串占8位，’’.’’之后的字符串占三位，多余的截断，不足的用空格补全。字符串中所有的小写字母转换为其大写形式，其余字符不变。 2.TODO 21234567891011121314151617181920212223242526272829303132333435363738394041424344/** TODO: * 将FAT文件名格式解码成原始的文件名 * * Hint:假设path是“FILE TXT”，则返回\"file.txt\"**/BYTE *path_decode(BYTE *path)&#123; BYTE *path_pre = malloc(MAX_SHORT_NAME_LEN * sizeof(BYTE)); int i,j,k,len; len=strlen(path); for(i=0;i&lt;8;i++)&#123;//对前8位字符进行操作 if(path[i]&gt;='A' &amp;&amp; path[i]&lt;='Z') path_pre[i]=tolower(path[i]); else&#123; if(path[i]!=' ') path_pre[i]=path[i]; else&#123; break; &#125; &#125; &#125; j=i; if(path[8]==' ')&#123; path_pre[j]='\\0'; &#125; else&#123; path_pre[j]='.'; j++; for(i=8;i&lt;11;i++)&#123;//对后3位字符进行操作 if(path[i]&gt;='A' &amp;&amp; path[i]&lt;='Z') path_pre[j++]=tolower(path[i]); else&#123; if(path[i]!=' ') path_pre[j++]=path[i]; else&#123; break; &#125; &#125; &#125; &#125; path_pre[j]='\\0'; return path_pre;&#125; 说明：该函数就是**path_split的反向操作，将输入路径的前8位转换成’.’之前的字符串，后三位转换成’.’之后的字符串，将空格去掉，小写字母变大写字母，其余字母保持不变。 3.TODO 31234567891011121314151617181920212223242526272829FAT16 *pre_init_fat16(void)&#123; FILE *fd; FAT16 *fat16_ins; fd = fopen(FAT_FILE_NAME, \"rb\"); if (fd == NULL) &#123; fprintf(stderr, \"Missing FAT16 image file!\\n\"); exit(EXIT_FAILURE); &#125; fat16_ins = malloc(sizeof(FAT16)); fat16_ins-&gt;fd = fd; /** TODO: * 初始化fat16_ins的其余成员变量 * Hint: root directory的大小与Bpb.BPB_RootEntCnt有关，并且是扇区对齐的 **/ BYTE buffer[BYTES_PER_SECTOR]; fread(fat16_ins-&gt;Bpb.BS_jmpBoot,sizeof(BYTE),0x200,fd); fat16_ins-&gt;FirstRootDirSecNum=fat16_ins-&gt;Bpb.BPB_RsvdSecCnt+fat16_ins-&gt;Bpb.BPB_FATSz16*fat16_ins-&gt;Bpb.BPB_NumFATS; fat16_ins-&gt;FirstDataSector=fat16_ins-&gt;FirstRootDirSecNum + BYTES_PER_DIR*fat16_ins-&gt;Bpb.BPB_RootEntCnt/fat16_ins-&gt;Bpb.BPB_BytsPerSec; return fat16_ins;&#125; 说明：该函数的功能是初始化fat16_ins的成员变量，对FAT16的定义在fat16.h文件中： 12345678910111213141516171819202122232425262728293031typedef struct&#123; FILE *fd; DWORD FirstRootDirSecNum; DWORD FirstDataSector; BPB_BS Bpb;&#125; FAT16;typedef struct &#123; BYTE BS_jmpBoot[3]; BYTE BS_OEMName[8]; WORD BPB_BytsPerSec; BYTE BPB_SecPerClus; WORD BPB_RsvdSecCnt; BYTE BPB_NumFATS; WORD BPB_RootEntCnt; WORD BPB_TotSec16; BYTE BPB_Media; WORD BPB_FATSz16; WORD BPB_SecPerTrk; WORD BPB_NumHeads; DWORD BPB_HiddSec; DWORD BPB_TotSec32; BYTE BS_DrvNum; BYTE BS_Reserved1; BYTE BS_BootSig; DWORD BS_VollID; BYTE BS_VollLab[11]; BYTE BS_FilSysType[8]; BYTE Reserved2[448]; WORD Signature_word;&#125; __attribute__ ((packed)) BPB_BS; 其中以BPB和BS为前缀的变量均存储在DBR扇区中，且这些变量按其偏移大小依次排列，故可以直接通过首地址进行填充： 1fread(fat16_ins-&gt;Bpb.BS_jmpBoot,sizeof(BYTE),0x200,fd); 至于FirstRootDirSecNum和FirstDataSector两个变量可以通过计算得出，具体计算方法的说明参见上文FAT16的存储结构中的说明。 4.TODO 412345678910111213/** TODO: * 返回簇号为ClusterN对应的FAT表项**/WORD fat_entry_by_cluster(FAT16 *fat16_ins, WORD ClusterN)&#123; BYTE sector_buffer[BYTES_PER_SECTOR]; int clusternum=fat16_ins-&gt;Bpb.BPB_RsvdSecCnt+ClusterN*2/BYTES_PER_SECTOR;//计算簇号对应扇区 int offset=ClusterN*2%BYTES_PER_SECTOR;//计算在该扇区内的偏移量 WORD FAT_content; sector_read(fat16_ins-&gt;fd,clusternum,sector_buffer);//读取该扇区内容 FAT_content=(WORD)sector_buffer[offset+1]*0x0100 + (WORD)sector_buffer[offset];//读取内容 return FAT_content;&#125; 说明： 由于一个文件与其存储在FAT1中的位置是*2的关系，故在计算簇号对应的扇区号与在该扇区中的偏移量的时候需要将簇号*2。 由于FAT文件系统的存储方式为小端存储，故在读取内容时，读取高地址处的内容作为高位，低地址处的作为低位。 5.TODO 5123456789101112131415161718192021222324252627282930313233343536373839/** * 从root directory开始，查找path对应的文件或目录，找到返回0，没找到返回1，并将Dir填充为查找到的对应目录项 * * Hint: 假设path是“/dir1/dir2/file”，则先在root directory中查找名为dir1的目录， * 然后在dir1中查找名为dir2的目录，最后在dir2中查找名为file的文件，找到则返回0，并且将file的目录项数据写入到参数Dir对应的DIR_ENTRY中**/int find_root(FAT16 *fat16_ins, DIR_ENTRY *Dir, const char *path)&#123; int pathDepth; char **paths = path_split((char *)path, &amp;pathDepth); BYTE *p; int ii,i, j,k,flag=0; int RootDirCnt = 1; BYTE buffer[BYTES_PER_SECTOR]; int RootDirSectors = (32*fat16_ins-&gt;Bpb.BPB_RootEntCnt+fat16_ins-&gt;Bpb.BPB_BytsPerSec-1)/fat16_ins-&gt;Bpb.BPB_BytsPerSec;//RootDirSectors为根目录中的扇区数 /** TODO: * 查找名字为paths[0]的目录项， * 如果找到目录，则根据pathDepth判断是否需要调用find_subdir继续查找， * * !!注意root directory可能包含多个扇区 **/ for(ii=0;ii&lt;RootDirSectors;ii++)&#123; sector_read(fat16_ins-&gt;fd, fat16_ins-&gt;FirstRootDirSecNum+ii, buffer);//读入每个扇区的内容 for (i = 0; i &lt; fat16_ins- &gt;Bpb.BPB_BytsPerSec/RootDirSectors; i++)&#123; //求出每个扇区中表项的个数 p=&amp;buffer[i*BYTES_PER_DIR];//读入Dir *Dir=*(DIR_ENTRY*)p; if(Dir-&gt;DIR_Name[0]==0x00 || Dir-&gt;DIR_Name[0]==0xe5)break; if(!strncmp(paths[0],Dir-&gt;DIR_Name,11)&amp;&amp;pathDepth&gt;1) return find_subdir(fat16_ins, Dir, paths, pathDepth, 1);//若名称相等且pathDepth&gt;1则调用find_subdir else if(!strncmp(paths[0],Dir-&gt;DIR_Name,11)&amp;&amp;pathDepth==1) return 0; &#125;&#125; return 1;&#125; 说明： Dir结构体的定义在fat16.h文件中 1234567891011121314typedef struct &#123; BYTE DIR_Name[11]; BYTE DIR_Attr; BYTE DIR_NTRes; BYTE DIR_CrtTimeTenth; WORD DIR_CrtTime; WORD DIR_CrtDate; WORD DIR_LstAccDate; WORD DIR_FstClusHI; WORD DIR_WrtTime; WORD DIR_WrtDate; WORD DIR_FstClusLO; DWORD DIR_FileSize;&#125; __attribute__ ((packed)) DIR_ENTRY; find_root函数的基本思路为遍历根目录下的每一个表项，将该表项的内容填充到Dir结构体中，判断DIR_Name是否为0(未分配)或0xe5(已删除)，若是则退出返回1，表明未找到。若不是则将当前传入路径与DIR_Name进行比较，若相等，则根据pathDepth判断是否还要调用find_subdir进一步查找表项。 6.TODO 61234567891011121314151617181920212223242526272829303132333435363738394041/** TODO: * 从子目录开始查找path对应的文件或目录，找到返回0，没找到返回1，并将Dir填充为查找到的对应目录项 * * Hint1: 在find_subdir入口处，Dir应该是要查找的这一级目录的表项，需要根据其中的簇号，读取这级目录对应的扇区数据 * Hint2: 目录的大小是未知的，可能跨越多个扇区或跨越多个簇；当查找到某表项以0x00开头就可以停止查找 * Hint3: 需要查找名字为paths[curDepth]的文件或目录，同样需要根据pathDepth判断是否继续调用find_subdir函数**/int find_subdir(FAT16 *fat16_ins, DIR_ENTRY *Dir, char **paths, int pathDepth, int curDepth)&#123; int ii,i, j,flag,m; int DirSecCnt = 1; BYTE* p; BYTE buffer[BYTES_PER_SECTOR]; WORD ClusterN, FatClusEntryVal, FirstSectorofCluster; ClusterN=Dir-&gt;DIR_FstClusLO;//对于FAT16，簇号存储在低16位中 FirstSectorofCluster = ((ClusterN - 2) * fat16_ins-&gt;Bpb.BPB_SecPerClus) + fat16_ins-&gt;FirstDataSector;//获得第一个簇号的扇区号 while(ClusterN&gt;=0x0002 &amp;&amp; ClusterN&lt;=0xFFEF)&#123; for(ii=0;ii&lt;fat16_ins-&gt;Bpb.BPB_SecPerClus;ii++)&#123;//外层以每一簇的扇区个数为界限进行循环 sector_read(fat16_ins-&gt;fd, FirstSectorofCluster+ii, buffer); for (i = 0; i &lt; BYTES_PER_SECTOR/BYTES_PER_DIR; i++)&#123; //内存以每个扇区中的FAT表项数进行循环 p=&amp;buffer[i*BYTES_PER_DIR]; *Dir=*(DIR_ENTRY*)p; if(Dir-&gt;DIR_Name[0]==0x00 || Dir-&gt;DIR_Name[0]==0xe5)&#123; break; break; &#125; else if(!strncmp(paths[curDepth],Dir-&gt;DIR_Name,11)) if(curDepth+1&lt;pathDepth) return find_subdir(fat16_ins, Dir, paths, pathDepth, curDepth+1); else return 0; &#125; &#125; FatClusEntryVal = fat_entry_by_cluster(fat16_ins, ClusterN);ClusterN=FatClusEntryVal;FirstSectorofCluster = ((ClusterN - 2) * fat16_ins-&gt;Bpb.BPB_SecPerClus) + fat16_ins-&gt;FirstDataSector;//获得下一个簇的第一个扇区号 &#125; return 1; &#125; 说明：该函数是通过簇号在数据区中寻找子目录的表项，先通过已获得的根目录的表项得到首簇号，然后得到该簇号所对应的第一个扇区号。循环时，外层循环次数为每一簇对应的扇区数，内层循环次数为每个扇区对应的表项数，内层循环结束后，要判断下一个簇的簇号及其对应的第一个扇区号。具体查找过程与find_root的过程类似。 7.TODO 7 &amp; TODO 81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586int fat16_readdir(const char *path, void *buffer, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi)&#123; FAT16 *Vol; BYTE sector_buffer[BYTES_PER_SECTOR]; int RootDirCnt = 1, DirSecCnt = 1, i; struct fuse_context *context; context = fuse_get_context(); Vol = (FAT16 *) context-&gt;private_data; sector_read(Vol-&gt;fd, Vol-&gt;FirstRootDirSecNum, sector_buffer); if (strcmp(path, \"/\") == 0) &#123; DIR_ENTRY Root; /** TODO: * 将root directory下的文件或目录通过filler填充到buffer中 * 注意不需要遍历子目录 **/ for (i = 1; i &lt;= Vol-&gt;Bpb.BPB_RootEntCnt; i++) &#123; memcpy(&amp;Root, &amp;sector_buffer[((i - 1) * BYTES_PER_DIR) % BYTES_PER_SECTOR], BYTES_PER_DIR);​ ​ if (Root.DIR_Name[0] == 0x00 || Root.DIR_Name[0]==0xe5) &#123;​ return 0;​ &#125;​ ​ if ((Root.DIR_Attr == ATTR_ARCHIVE || Root.DIR_Attr == ATTR_DIRECTORY) &amp;&amp; Root.DIR_Name[0]!=0xE5) &#123;​ const char *filename = (const char *) path_decode(Root.DIR_Name);​ filler(buffer, filename, NULL, 0);​ &#125;​ ​ if (i % 16 == 0 &amp;&amp; i != Vol-&gt;Bpb.BPB_RootEntCnt) &#123;​ sector_read(Vol-&gt;fd, Vol-&gt;FirstRootDirSecNum + RootDirCnt, sector_buffer);​ RootDirCnt++;​ &#125;​ &#125; &#125; else &#123;​ DIR_ENTRY Dir;​ /** TODO: * 通过find_root获取path对应的目录的目录项， * 然后访问该目录，将其下的文件或目录通过filler填充到buffer中， * 同样注意不需要遍历子目录 * Hint: 需要考虑目录大小，可能跨扇区，跨簇 **/ find_root(Vol, &amp;Dir, path); WORD ClusterN = Dir.DIR_FstClusLO; WORD FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN); WORD FirstSectorofCluster = ((ClusterN - 2) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector; sector_read(Vol-&gt;fd, FirstSectorofCluster, sector_buffer); for (i = 1; Dir.DIR_Name[0] != 0x00 &amp;&amp; Dir.DIR_Name[0]!=0xe5 ; i++) &#123; if(ClusterN&lt;0x0002 || ClusterN&gt;0xFFEF) break; memcpy(&amp;Dir, &amp;sector_buffer[((i - 1) * BYTES_PER_DIR) % BYTES_PER_SECTOR], BYTES_PER_DIR); if ((Dir.DIR_Attr == ATTR_ARCHIVE || Dir.DIR_Attr == ATTR_DIRECTORY) &amp;&amp; Dir.DIR_Name[0]!=0xE5) &#123; const char *filename = (const char *) path_decode(Dir.DIR_Name); filler(buffer, filename, NULL, 0); &#125; if (i % 16 == 0) &#123; //一个扇区的表项遍历结束 if (DirSecCnt &lt; Vol-&gt;Bpb.BPB_SecPerClus) &#123; sector_read(Vol-&gt;fd, FirstSectorofCluster + DirSecCnt, sector_buffer);//读取该簇的下一个扇区 DirSecCnt++; &#125; else &#123;//否则读取下一个簇的第一个扇区号 if (FatClusEntryVal == 0xffff) &#123; return 0; &#125; ClusterN = FatClusEntryVal; FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN); FirstSectorofCluster = ((ClusterN - 2) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector; sector_read(Vol-&gt;fd, FirstSectorofCluster, sector_buffer); i = 0; DirSecCnt = 1; &#125; &#125; &#125; &#125; return 0;&#125; 说明：fat16_readdir函数用来读取相应目录所对应的文件内容，其具体操作过程分为两步： 当传入路径为’/‘时进行单独处理，由于’/‘代表根目录，所以当传入路径为’/‘时，通过遍历根目录中的每一个表项将根目录下的所有内容全部通过filler填充到buffer中，每当一个扇区中的表项遍历结束需要读取下一个扇区； 当传入路径为其它时，先调用find_root函数来获得该路径所对应的表项，然后到数据区取数据，具体的寻找过程为先获得首簇号的第一个扇区号，然后对该扇区中的每个表项进行遍历，通过filler读入到buffer中，若该扇区中的表项遍历结束判断该簇中的扇区是否遍历结束，若是则获取下一簇，否则继续读取该簇的下一个扇区。 由于文件可操作的属性不同，如图： 只有文件为子目录或存档时方可进行读取，且为了避免将已删除的文件读入，需判断DIR_Name不是0xe5。 8.TODO 9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** TODO: * 从path对应的文件的offset字节处开始读取size字节的数据到buffer中，并返回实际读取的字节数 * * Hint: 文件大小属性是Dir.DIR_FileSize；当offset超过文件大小时，应该返回0**/int fat16_read(const char *path, char *buffer, size_t size, off_t offset, struct fuse_file_info *fi)&#123; int i, j; BYTE *sector_buffer = malloc((size + offset) * sizeof(BYTE));//开辟一个大小为size+offset的空间 FAT16 *Vol; struct fuse_context *context; context = fuse_get_context(); Vol = (FAT16 *) context-&gt;private_data; DIR_ENTRY Dir; find_root(Vol, &amp;Dir, path); WORD ClusterN = Dir.DIR_FstClusLO; WORD FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN); WORD FirstSectorofCluster = ((ClusterN - 2) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector; for (i = 0, j = 0; i &lt; size + offset; i += BYTES_PER_SECTOR, j++) &#123; sector_read(Vol-&gt;fd, FirstSectorofCluster + j, sector_buffer + i);//读取每个扇区内容 if ((j + 1) % Vol-&gt;Bpb.BPB_SecPerClus == 0) &#123;//获取下一个簇的簇号及其对应第一个扇区号 ClusterN = FatClusEntryVal; if (FatClusEntryVal == 0xffff) &#123; break;//若读到末尾处时直接跳出循环 &#125; FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN); FirstSectorofCluster = ((ClusterN - 2) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector; j = -1;//j++后变为0 &#125; &#125; if (offset &lt; Dir.DIR_FileSize) &#123;//读取offset偏移处的内容 memcpy(buffer, sector_buffer + offset, size); &#125; else &#123; size = 0;//否则size为0 &#125; free(sector_buffer); return size;&#125; 说明：该函数的功能为：从path对应的文件的offset字节处开始读取size字节的数据到buffer中，并返回实际读取的字节数。故开辟一个大小为size+offset的空间，读取每个扇区内容，当该簇结束且还未到达offset处时，继续获取下一个簇的簇号及其对应第一个扇区号，最后当offset小于文件大小时，从offset处读入size大小的数据，并返回字节数，否则返回字节数为0。","comments":true,"tags":[{"name":"FAT","slug":"FAT","permalink":"http://fentuoli.github.io/tags/FAT/"},{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"},{"name":"OS","slug":"OS","permalink":"http://fentuoli.github.io/tags/OS/"}]},{"title":"DOM笔记","date":"2020-05-05T05:43:36.000Z","path":"2020/05/05/DOM笔记/","text":"DOM：documentDOM节点 子节点：oUl.childNodes，只算第一层属性： length nodeType==3 -&gt;文本节点==1 -&gt;元素节点 children：只包括元素，不包括文本 父节点：oUl.parentNode 用来定位的父节点：offsetParent 首尾子节点：firstChild/firstElementChild/lastChild/lastElementChild 兄弟节点：nextSibling/nextElementSilbing/previousSibling/previousElementSibling 设置属性 getAttribute(名称) setAttribute(名称，值) removeAttribute(名称) 用className选择元素! 创建、插入、删除元素 创建：12oLi&#x3D;document.createElement(&quot;li&quot;);oUl.appendChild(oLi)&#x2F;&#x2F;父级.appendChild(oLi) 插入元素：1父级.insertBefore(名称，原有节点) 删除元素：1父级.removeChild(子节点) 文档碎片提高DOM操作性能document.creatDocumentFragment(); 表格应用 getElementsByTagName(‘tbody’)=tBodies getElementsByTagName(‘tr’)=rows getElementsByTagName(‘td’)=cells tHead，tFoot 表格添加 表格删除 模糊大小写：toLowerCase()：将大写转为小写 模糊搜索：search()方法，返回子串出现位置 多关键词搜索：str.split(‘ ‘)，将字符串切分成数组，每个分别查找一次","comments":true,"tags":[{"name":"dom","slug":"dom","permalink":"http://fentuoli.github.io/tags/dom/"},{"name":"Web Front-end","slug":"Web-Front-end","permalink":"http://fentuoli.github.io/tags/Web-Front-end/"}]},{"title":"Javascript笔记","date":"2020-05-05T05:36:13.000Z","path":"2020/05/05/Javascript笔记/","text":"本篇文章是我自学网易云课堂：智能社:JavaScript-从入门到精通后写的学习笔记，有需要的朋友可自行搜索！PS：本课程是我找到的所有讲解javascript最明白易懂的课程 Javascript功能交互、修改样式tip：className的使用（控制class)；JS允许连等 组成 ECMAScript(解释器)：翻译 DOM：document object model，操作HTML的能力 BOM：browser object model 变量类型 number string boolean undefined object function 一个变量应该只存放一种类型的数据 变量转换显示类型转换： parseInt：把字符串转成整数 parseFloat：把字符串转成小数 NaN和NaN不相等(用isNaN判断) 隐式类型转换： ==：先转换类型，然后比较 ===：不转换类型，直接比 !=和!==：同上 “+”功能： 字符串连接 数字相加 “-”功能：数字相减 变量作用域和闭包 作用域：局部、全局变量 闭包：子函数可以使用父函数的局部变量 程序流程控制 判断：if、switch、?:(三目运算符)，用法：条件?语句1:语句2，替换if-else 循环：while、for 跳出：break、continue 真：true、非零数字、非空字符串、非空对象 假：false、数字零、空字符串、空对象、undefined 字典循环for(var i in json) 数组基础 定义：var arr=[1,2,3]；arr=new Array(1,2,3) 添加：arr.push(4) 删除：arr.pop() 从头部删除：arr.shift() 从头部添加：arr.unshift() 删除：arr.splice(起点，长度) 插入：arr.splice(起点，长度，元素…) 连接：a.concat(b) 把数组变为字符串：arr.join(‘-‘)（用’-‘连接数组中的元素） 字符串 排序：arr.sort() 数字排序：arr.sort(function (n1,n2){return n1-n2;} 函数 函数传参：参数就是占位符 函数参数可变：arguments(arguments.length) 操作属性的方法：a.value/a[‘value’] 提取行间事件 function 名字() {} button.onclick=function() 将script代码写在head中时有可能出错，用window.onload=function( ){};来实现（先加载后执行该段代码） 元素.style.属性=xxx是修改行间样式，之后再修改className不会有效果 提取非行间样式：oDiv.currentStyle.属性、getComputedSytle(oDiv,false).属性 获取一组元素getElementsByTagName获取的是数组 选项卡 this：当前发生事件的元素 可以通过js给标签添加新的属性 innerHTML 标签中显示的文字，可以按html的格式来写 定时器 开启定时器 间隔型：setInterval(事件，时间) 延时性：setTimeout(事件，时间) 关闭定时器 clearInterval() clearTimeout() Date对象：var oDate=new Date(); oDate.getHours() oDate.getMinutes() oDate.getSeconds() oDate.getFullYear() oDate.getMonth()+1 oDate.getDate() oDate.getDay()（返回星期，0为周日…） 由于兼容性，为获取字符串的某一位，要将str[0]改为str.charAt(0) 延时提示框 鼠标移入：onmouseover 鼠标移出：onmouseout 用setTimeout控制延时消失 当鼠标移入提示框时，关闭定时器 当鼠标移出提示框时，提示框消失 无缝滚动 offsetLeft/offsetTop获取物体边距 offsetHeight/offsetWidth 改变滚动方向","comments":true,"tags":[{"name":"javascript","slug":"javascript","permalink":"http://fentuoli.github.io/tags/javascript/"},{"name":"Web Front-end","slug":"Web-Front-end","permalink":"http://fentuoli.github.io/tags/Web-Front-end/"}]},{"title":"HTML笔记","date":"2020-05-05T04:50:47.000Z","path":"2020/05/05/HTML笔记/","text":"本篇文章是我自学网易云课堂：撩课-玩转H5大前端-HTML+CSS后写的学习笔记，有需要的朋友可自行搜索！ HTML web标准：结构(html)、表现(css)、行为(js) HTML：超文本标记语言 HTML文档结构：&lt;html&gt;、&lt;head&gt;(外部资源引用等)、&lt;body&gt;(网页主体) &lt;head&gt; &lt;title&gt;展示网页标题、&lt;meta&gt;元标签：描述HTML网页文档的属性(提供文档字符集、使用语言、作者等描述信息) 闭合标签中填写内容、单标签中填写属性 样式/节 123&lt;style&gt;p&#123;&#125;&lt;/style&gt;：定义文本的标签样式信息 &lt;body&gt; 标题标签：以h开头，h1到h6，&lt;br&gt;进行分割 段落标签：&lt;p&gt;标签 图像标签： &lt;img src=”url” alt=”图片描述”&gt; 包括一些可选属性 换行标签：&lt;br&gt; 表单标签： &lt;input type=”类型” value=”默认文字” placeholder=”提示文字”&gt; 类型有text、password、date、color、file(文件上传功能)、checkbox(复选框)、radio(单选框)等 超级链接a标签： &lt;a href=””&gt;文字&lt;/a&gt; 锚点跳转：&lt;a href=”#one”&gt;&lt;/a&gt; &lt;p id=”one”&gt;段落&lt;/p&gt; 列表标签： 123&lt;ul type=\"\"&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;/ul&gt; 123&lt;ol&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;/ol&gt; 1234&lt;dl&gt; &lt;dt&gt;标题&lt;/dt&gt; &lt;dd&gt;定义列表中条目的定义部分&lt;/dd&gt; &lt;/dl&gt; 表单标签： 123456789&lt;form action=\"服务器url\"&gt; &lt;lable&gt;用户名：&lt;/lable&gt; &lt;input type=\"text\"&gt; &lt;textarea rows=\"10\" cols=\"10\"&gt;多行文本输入空间&lt;/textarea&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;select name=\"sex\"&gt; &lt;option value=\"男&gt;男&lt;/option&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 节标签： &lt;div&gt;内容&lt;/div&gt;(对文档结构进行划分，纵向) &lt;span&gt;内容&lt;span&gt;(对页面进行布局，横向) 语义化标签(用于语义化替换&lt;div&gt;、媒介标签(video、audio)、表单控件标签、绘图标签) 标签使用补充 标签之间的关系 祖先元素 后代元素 父元素、子元素、兄弟元素 设置浏览器标签图标： favicon.ico 在线制作：www.faviconico.org 放在根目录 meta标签属性补充：定义网站关键字和网站描述 CSS 作用：美化网页 HTML用来构建网页整体布局 一重或多重声明 CSS样式： 行内样式：作用于一行 页内样式：作用于整个页面 外部样式：新建一个stylesheet文件，在原文件&lt;head&gt;中引入：&lt;link rel=”stylesheet” href=”路径”&gt; CSS选择器 通用选择器：*（优先级最低） 标签选择器 类选择器：.类名{ }(类名在标签中用class定义，如：&lt;div class=”test”&gt;，一个标签可以有多个类名) id选择器：为标有特定id的HTML元素设置样式，格式：#id名{ }，id在标签中用id定义，id只能用于一个标签 复合选择器：如div.test1{ }或div#main 群组选择器(并列选择器)，如：div,span,.test1{ }，同时作用于多个标签 后代选择器：格式：祖先元素 后代元素 后代元素{ } 直接后代选择器：父元素&gt;子元素{ } 兄弟选择器：查找后边一个兄弟元素：兄弟元素+兄弟元素{}；查找后边所有兄弟元素：兄弟元素~兄弟元素{ } 属性选择器：选择有特殊属性的标签，格式：标签[属性][属性]{ } 伪类和伪元素 否定伪类 选择器的优先级：选择器的权值：* ：0；类：10；属性：10；伪类/伪元素：10；id：100；复合：相加；important：1000；(!important) 权值大的优先级高，权值相同后定义的优先级高 标签元素划分： 块元素：ul,li,form,hr,p,h1-h6,div（自己单独占一行，就像一个段落，可以改变高度和宽度） 内联（行内）元素：不会自己独占一行，会一直往后排，宽度、高度、内边距都不可改变，常见的有：a,big,br,em,img,input,label,select等 内联-块级元素：select,textarea,button,input,在一行显示，可以设置宽度和高度 块元素与行内元素互换：块-&gt;行内：display:inline；行内-&gt;块：display:block；行内块级-&gt;块：display:block 块属性：（见讲义） 盒子模型：padding,border…(盒子圆角：border-radius) 标准盒子模型 IE盒子模型 浮动：float 标签居中：水平/垂直居中 行内水平：text-align:center； 块级元素水平居中：margin:0 auto； 行内标签垂直居中：line-height和外部保持一致 行内元素水平对齐：vertical-align:middle css常见属性： visibility:visible/hidden（会占位） cursor:pointer/mov/help… color font text-decoration:none(去除下划线) text-indent:2% 首行缩进 text-align 对齐 overflow 控制文字溢出 页面布局 定位(position)： static relative absolute(相对于父标签) fixed relative：以自身为参照，层级提高一级 absolute：相对于距离它最近的开启了定位的祖先元素进行定位，否则相对于浏览器窗口进行定位，提高一个层级，内联变块 fixed：相对于浏览器窗口进行定位，不会随滚动条滚动 标签层级：定位元素&gt;浮动元素&gt;文档流中的元素 元素开启定位后，可通过z-index来设置元素的层级 z-index越高元素越优先显示 父元素永远不会覆盖子元素 标签设置圆角：border-radius ​","comments":true,"tags":[{"name":"HTML","slug":"HTML","permalink":"http://fentuoli.github.io/tags/HTML/"},{"name":"Web Front-end","slug":"Web-Front-end","permalink":"http://fentuoli.github.io/tags/Web-Front-end/"}]},{"title":"编译原理之文法分析","date":"2020-05-05T00:37:54.000Z","path":"2020/05/05/编译原理之文法分析/","text":"自顶向下：采用回溯 递归向下：对每个非终结符进行分治讨论 LL(1）分析算法： 从左向右，最左推导，采用一个前看符号 LL(1)分析表： 弹出非终结符后应该压入哪条产生式的右部 FIRST集计算规则：1. N-&gt;a 并入 N-&gt;M1M2M3… M1的FIRST并入N的FIRST 直至第一个推不出空的非终结符的FIRST并入N的FIRST 构造LL(1)分析表，将FIRST推广到任意串上 每个表项只有一个，称为LL(1)文法 无冲突要求两条FIRST_S的交集为空 FOLLOW集用来判断当一个非终结符可以推出空时，什么字符（产生式规则）可以跟在它后面 FOLLOW计算规则： 从一条产生式的最后一个字符开始进行判断 采用不动点算法，直至不发生改变 计算FIRST_S:若产生式右部均为NULLABLE，则将左部非终结符的FOLLOW也加进去 LL(1)冲突解决：1. 消除左递归 提取左公因子LR(0)分析算法：自底向上 判断能否进行规约 最右推导的逆过程 将栈上的右部弹掉，压入左部 从左向右读入程序，最右推导，不用前看符号 缺点： 延迟错误发现时机，可能包含移进-规约冲突 LR(0)分析表： Sn后的n指项目序号，Rn后的n值第几条文法符号 ACTION和GOTO表 SLR分析算法： 与LR(0)区别：对于状态i上的项目X-&gt;α●，仅对y∈FOLLOW(X)添加ACTION[i,y] 优点： 减少需要规约的情况 可能去除移进规约冲突 缺点： 移进规约冲突仍可能存在 LR(1)分析算法： 与LR(0)相比：仅闭包的计算不同：对项目[X-&gt;α●Yβ,a]，添加[Y-&gt;●γ，b]到项目集，其中b∈FIRST_S(βα) 如果有移进规约冲突则不是LR(1)文法 二义性文法无法使用LR分析法 二义性文法的处理方法： 优先级 结合性 悬空else LALR分析算法： 把类似的项目集进行合并 可能带来规约规约冲突 补充： SLR(1)判断规则：方法一：画出文法的LR(0)自动机，如果没有移进–规约冲突，即shift–reduce 冲突，则该文法是SLR(1)文法 LALR(1)和LR(1)的判断规则：画出文法的LR(1)自动机，如果没有同心项且没有状态冲突，则该文法是LALR(1)文法；如果有同心项且合并同心项有状态冲突，则是LR（1）文法 证明是LL(1)文法： ：对任意两个产生式A→α|β 都有：1） First(α )∩First(β )=Φ2）若 β⇒* ε, 则First(A)∩Follow(A)=Φ 正则表达式： 不能用于配对或嵌套 表示给定结构的固定次数的重复或没有指定次数的重复","comments":true,"tags":[{"name":"Lessons","slug":"Lessons","permalink":"http://fentuoli.github.io/tags/Lessons/"},{"name":"Compiler","slug":"Compiler","permalink":"http://fentuoli.github.io/tags/Compiler/"}]},{"title":"写给自己的博客","date":"2020-04-30T13:07:15.000Z","path":"2020/04/30/前言/","text":"创建这个博客是为了鼓励自己能阶段性地总结学过的东西，改掉学过就忘的毛病。我把自己踩过的坑，以及解决方案写上来，也希望对其他人有所帮助。 博客上面是我的一些代码的实现思路，完整代码可参见我的github，欢迎大家访问并follow！ 愿与君共勉！","comments":true,"tags":[{"name":"前言","slug":"前言","permalink":"http://fentuoli.github.io/tags/%E5%89%8D%E8%A8%80/"}]}]