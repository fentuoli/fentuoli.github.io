[{"title":"OS实验","date":"2020-05-05T06:07:11.000Z","path":"2020/05/05/OS实验/","text":"操作系统实验题目：FAT文件系统的实现本实验是操作系统课程的要求实验，大致为实现一个FAT文件系统，具体要求和完整代码请参见我的github地址： https://github.com/fentuoli/FAT-file-system 一、实验内容及要求​ 熟悉FAT16的存储结构，利用FUSE实现一个只读的FAT文件系统 。 二、实验准备工作1.熟悉使用FUSE 配置FUSE环境 123456wget -O libfuse-2.9.5.zip https://codeload.github.com/libfuse/libfuse/zip/fuse_2_9_5 unzip libfuse-2.9.5.zip cd libfuse-fuse_2_9_5/ ./makeconf.sh ./configure --prefix=/usr make -j4 sudo make install 编译出错处理 12sudo apt install libtool sudo apt install autoconf 测试FUSE 123cd example mkdir fuse_test_dir ./fusexmp -d fuse_test_dir 用Ctrl+C结束程序。 2.FAT文件系统 FAT格式磁盘镜像的制作过程 1234dd if=/dev/zero of=fat-disk.img bs=1M count=100mkfs.vfat -F 16 fat-disk.imgmkdir mdir mount fat-disk.img mdir FAT16的存储结构 FAT16文件系统的基本结构依次为：DBR扇区、FAT表1、FAT表2、根目录和数据区，FAT16格式的磁盘的组织 方式如下图所示： DBR扇区：由于lab4.pdf上所给的DBR扇区内容表格不够完整，所以我又自行检索了一个更加完整的表格 我们可以根据上述的BPB的字段计算FAT系统的各个部分的偏移地址和大小。 12FatStartSector = BPB_ResvSecCnt;FatSectors = BPB_FATSz * BPB_NumFATs; 根目录区的偏移地址和大小可以计算如下，计算根目录扇区数量时乘以的32是指目录中的一条记录长度为32个字节。 加上BPB_BytsPerSec再减去1是为了做除法运算时向上取整的。 12RootDirStartSector = FatStartSector + FatSectors;RootDirSectors = (32 * BPB_RootEntCnt + BPB_BytsPerSec - 1) / BPB_BytsPerSec; 根目录区之后就是数据区，用于记录实际的文件和目录内容的区域。我们可以通过如下的语句计算数据区的偏移地址和大小。 12DataStartSector = RootDirStartSector + RootDirSectors;DataSectors = BPB_TotSec - DataStartSector; FAT表： 根目录：：FAT文件系统的一个重要思想是把目录当作一个特殊文件来处理，在FAT16中，虽然根目录地位并不等 同于普通的目录，但其组织形式和普通的目录并没有不同。不管目录文件所占空间为多少簇，系统都会以32个 字节为单位进行目录文件所占簇的分配。每个32字节目录项表示的具体含义如下： FAT表与文件定位： ​ FAT16文件系统从根目录所占的32个扇区之后的第一个扇区开始以簇为单位进行数据的处 理，这之前仍以扇区为单位。对于根目录之后的第一个簇，系统并不编号为0号簇或1号簇，而是编号为2号簇， 也就是说数据区顺序上的第1个簇也是编号上的2号簇。 ​ 假设一个文件，其首簇号是2，则查看FAT的相对偏移0x4~0x5的内容，此处为0xFFFF，表示存储在2号簇上的文 件是个小文件，只占用1个簇便结束了。 假设另一个文件的首簇号是8，则查看FAT的相对偏移0x10-0x11的内容，为0x0009，就是说该文件继8号簇后 的内容会存放在9号簇中；继续查看9号簇的FAT表项内容是0x000A，该文件继9簇后的内容会存放在10号簇 中，继续这个过程，会发现文件在11号簇结束。 三、实验操作过程1.TODO 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** TODO: * 将输入路径按“/”分割成多个字符串，并按照FAT文件名格式转换字符串 * * Hint1:假设pathInput为“/dir1/dir2/file.txt”，则将其分割成“dir1”，“dir2”，“file.txt”， * 每个字符串转换成长度为11的FAT格式的文件名，如“file.txt”转换成“FILE TXT”， * 返回转换后的字符串数组，并将*pathDepth_ret设置为3 * Hint2:可能会出现过长的字符串输入，如“/.Trash-1000”，需要自行截断字符串**/char **path_split(char *pathInput, int *pathDepth_ret)&#123; int pathDepth = 1; char **pathchange = malloc(pathDepth * sizeof(char *)); int len,i,j,k,pathnum=0,m=0,n=0; len=strlen(pathInput); for(i=0;i&lt;len;i++)&#123; if(pathInput[i]!='/') continue; else pathnum++; &#125; *pathDepth_ret=pathnum; pathDepth=pathnum; for(i=0;i&lt;pathnum;i++) pathchange[i]=(char *)malloc(MAX_SHORT_NAME_LEN *sizeof(char));//pathchange中存储最终转换为FAT格式的路径 char pathdiv[pathnum][30],a[pathnum][30],b[pathnum][30];//pathdiv中存储按'/'进行分割的路径 for(i=1;i&lt;len;i++)&#123; if(pathInput[i]!='/')&#123; pathdiv[m][n]=pathInput[i]; n++; &#125; else&#123; pathdiv[m][n]='\\0'; m++; n=0; &#125; &#125; pathdiv[m][n]='\\0'; for(i=0;i&lt;pathnum;i++)&#123; k=0; for(j=0;j&lt;strlen(pathdiv[i]);j++)&#123; b[i][0]='\\0'; if(pathdiv[i][j]!='.') a[i][j]=pathdiv[i][j]; //a中存储'.'之前的字符串 else&#123; a[i][j]='\\0'; j++; for(k=j;k&lt;strlen(pathdiv[i]);k++)&#123; b[i][k-j]=pathdiv[i][k]; &#125; b[i][k-j]='\\0';//b中存储'.'之后的字符串 break; &#125; &#125; a[i][j]='\\0'; if(strlen(a[i])&lt;8)&#123; for(j=0;j&lt;strlen(a[i]);j++)&#123; if(a[i][j]&gt;='a' &amp;&amp; a[i][j]&lt;='z') pathchange[i][j]=toupper(a[i][j]);//toupper函数将小写字母转换为大写字母 else pathchange[i][j]=a[i][j];//非小写字母的字符保存不变 &#125; for(k=j;k&lt;8;k++) pathchange[i][k]=' ';//补空格 &#125; else&#123; for(j=0;j&lt;8;j++)&#123; if(a[i][j]&gt;='a' &amp;&amp; a[i][j]&lt;='z') pathchange[i][j]=toupper(a[i][j]); else pathchange[i][j]=a[i][j]; &#125; &#125; if(strlen(b[i])&lt;3)&#123; for(j=0;j&lt;strlen(b[i]);j++)&#123; if(b[i][j]&gt;='a' &amp;&amp; b[i][j]&lt;='z') pathchange[i][8+j]=toupper(b[i][j]); else pathchange[i][8+j]=b[i][j]; &#125; for(k=j;k&lt;3;k++) pathchange[i][k+8]=' '; &#125; else&#123; for(j=0;j&lt;3;j++)&#123; if(b[i][j]&gt;='a' &amp;&amp; b[i][j]&lt;='z') pathchange[i][8+j]=toupper(b[i][j]); else pathchange[i][8+j]=b[i][j]; &#125; &#125; &#125; for(i=0;i&lt;pathnum;i++)&#123; pathchange[i][11]='\\0'; &#125; return pathchange;&#125; 说明：**path_split函数的功能就是将输入路径按’’/‘’进行分割，并将每一级目录按’’.’’进行划分，’’.’’之前的字符串占8位，’’.’’之后的字符串占三位，多余的截断，不足的用空格补全。字符串中所有的小写字母转换为其大写形式，其余字符不变。 2.TODO 21234567891011121314151617181920212223242526272829303132333435363738394041424344/** TODO: * 将FAT文件名格式解码成原始的文件名 * * Hint:假设path是“FILE TXT”，则返回\"file.txt\"**/BYTE *path_decode(BYTE *path)&#123; BYTE *path_pre = malloc(MAX_SHORT_NAME_LEN * sizeof(BYTE)); int i,j,k,len; len=strlen(path); for(i=0;i&lt;8;i++)&#123;//对前8位字符进行操作 if(path[i]&gt;='A' &amp;&amp; path[i]&lt;='Z') path_pre[i]=tolower(path[i]); else&#123; if(path[i]!=' ') path_pre[i]=path[i]; else&#123; break; &#125; &#125; &#125; j=i; if(path[8]==' ')&#123; path_pre[j]='\\0'; &#125; else&#123; path_pre[j]='.'; j++; for(i=8;i&lt;11;i++)&#123;//对后3位字符进行操作 if(path[i]&gt;='A' &amp;&amp; path[i]&lt;='Z') path_pre[j++]=tolower(path[i]); else&#123; if(path[i]!=' ') path_pre[j++]=path[i]; else&#123; break; &#125; &#125; &#125; &#125; path_pre[j]='\\0'; return path_pre;&#125; 说明：该函数就是**path_split的反向操作，将输入路径的前8位转换成’.’之前的字符串，后三位转换成’.’之后的字符串，将空格去掉，小写字母变大写字母，其余字母保持不变。 3.TODO 31234567891011121314151617181920212223242526272829FAT16 *pre_init_fat16(void)&#123; FILE *fd; FAT16 *fat16_ins; fd = fopen(FAT_FILE_NAME, \"rb\"); if (fd == NULL) &#123; fprintf(stderr, \"Missing FAT16 image file!\\n\"); exit(EXIT_FAILURE); &#125; fat16_ins = malloc(sizeof(FAT16)); fat16_ins-&gt;fd = fd; /** TODO: * 初始化fat16_ins的其余成员变量 * Hint: root directory的大小与Bpb.BPB_RootEntCnt有关，并且是扇区对齐的 **/ BYTE buffer[BYTES_PER_SECTOR]; fread(fat16_ins-&gt;Bpb.BS_jmpBoot,sizeof(BYTE),0x200,fd); fat16_ins-&gt;FirstRootDirSecNum=fat16_ins-&gt;Bpb.BPB_RsvdSecCnt+fat16_ins-&gt;Bpb.BPB_FATSz16*fat16_ins-&gt;Bpb.BPB_NumFATS; fat16_ins-&gt;FirstDataSector=fat16_ins-&gt;FirstRootDirSecNum + BYTES_PER_DIR*fat16_ins-&gt;Bpb.BPB_RootEntCnt/fat16_ins-&gt;Bpb.BPB_BytsPerSec; return fat16_ins;&#125; 说明：该函数的功能是初始化fat16_ins的成员变量，对FAT16的定义在fat16.h文件中： 12345678910111213141516171819202122232425262728293031typedef struct&#123; FILE *fd; DWORD FirstRootDirSecNum; DWORD FirstDataSector; BPB_BS Bpb;&#125; FAT16;typedef struct &#123; BYTE BS_jmpBoot[3]; BYTE BS_OEMName[8]; WORD BPB_BytsPerSec; BYTE BPB_SecPerClus; WORD BPB_RsvdSecCnt; BYTE BPB_NumFATS; WORD BPB_RootEntCnt; WORD BPB_TotSec16; BYTE BPB_Media; WORD BPB_FATSz16; WORD BPB_SecPerTrk; WORD BPB_NumHeads; DWORD BPB_HiddSec; DWORD BPB_TotSec32; BYTE BS_DrvNum; BYTE BS_Reserved1; BYTE BS_BootSig; DWORD BS_VollID; BYTE BS_VollLab[11]; BYTE BS_FilSysType[8]; BYTE Reserved2[448]; WORD Signature_word;&#125; __attribute__ ((packed)) BPB_BS; 其中以BPB和BS为前缀的变量均存储在DBR扇区中，且这些变量按其偏移大小依次排列，故可以直接通过首地址进行填充： 1fread(fat16_ins-&gt;Bpb.BS_jmpBoot,sizeof(BYTE),0x200,fd); 至于FirstRootDirSecNum和FirstDataSector两个变量可以通过计算得出，具体计算方法的说明参见上文FAT16的存储结构中的说明。 4.TODO 412345678910111213/** TODO: * 返回簇号为ClusterN对应的FAT表项**/WORD fat_entry_by_cluster(FAT16 *fat16_ins, WORD ClusterN)&#123; BYTE sector_buffer[BYTES_PER_SECTOR]; int clusternum=fat16_ins-&gt;Bpb.BPB_RsvdSecCnt+ClusterN*2/BYTES_PER_SECTOR;//计算簇号对应扇区 int offset=ClusterN*2%BYTES_PER_SECTOR;//计算在该扇区内的偏移量 WORD FAT_content; sector_read(fat16_ins-&gt;fd,clusternum,sector_buffer);//读取该扇区内容 FAT_content=(WORD)sector_buffer[offset+1]*0x0100 + (WORD)sector_buffer[offset];//读取内容 return FAT_content;&#125; 说明： 由于一个文件与其存储在FAT1中的位置是*2的关系，故在计算簇号对应的扇区号与在该扇区中的偏移量的时候需要将簇号*2。 由于FAT文件系统的存储方式为小端存储，故在读取内容时，读取高地址处的内容作为高位，低地址处的作为低位。 5.TODO 5123456789101112131415161718192021222324252627282930313233343536373839/** * 从root directory开始，查找path对应的文件或目录，找到返回0，没找到返回1，并将Dir填充为查找到的对应目录项 * * Hint: 假设path是“/dir1/dir2/file”，则先在root directory中查找名为dir1的目录， * 然后在dir1中查找名为dir2的目录，最后在dir2中查找名为file的文件，找到则返回0，并且将file的目录项数据写入到参数Dir对应的DIR_ENTRY中**/int find_root(FAT16 *fat16_ins, DIR_ENTRY *Dir, const char *path)&#123; int pathDepth; char **paths = path_split((char *)path, &amp;pathDepth); BYTE *p; int ii,i, j,k,flag=0; int RootDirCnt = 1; BYTE buffer[BYTES_PER_SECTOR]; int RootDirSectors = (32*fat16_ins-&gt;Bpb.BPB_RootEntCnt+fat16_ins-&gt;Bpb.BPB_BytsPerSec-1)/fat16_ins-&gt;Bpb.BPB_BytsPerSec;//RootDirSectors为根目录中的扇区数 /** TODO: * 查找名字为paths[0]的目录项， * 如果找到目录，则根据pathDepth判断是否需要调用find_subdir继续查找， * * !!注意root directory可能包含多个扇区 **/ for(ii=0;ii&lt;RootDirSectors;ii++)&#123; sector_read(fat16_ins-&gt;fd, fat16_ins-&gt;FirstRootDirSecNum+ii, buffer);//读入每个扇区的内容 for (i = 0; i &lt; fat16_ins- &gt;Bpb.BPB_BytsPerSec/RootDirSectors; i++)&#123; //求出每个扇区中表项的个数 p=&amp;buffer[i*BYTES_PER_DIR];//读入Dir *Dir=*(DIR_ENTRY*)p; if(Dir-&gt;DIR_Name[0]==0x00 || Dir-&gt;DIR_Name[0]==0xe5)break; if(!strncmp(paths[0],Dir-&gt;DIR_Name,11)&amp;&amp;pathDepth&gt;1) return find_subdir(fat16_ins, Dir, paths, pathDepth, 1);//若名称相等且pathDepth&gt;1则调用find_subdir else if(!strncmp(paths[0],Dir-&gt;DIR_Name,11)&amp;&amp;pathDepth==1) return 0; &#125;&#125; return 1;&#125; 说明： Dir结构体的定义在fat16.h文件中 1234567891011121314typedef struct &#123; BYTE DIR_Name[11]; BYTE DIR_Attr; BYTE DIR_NTRes; BYTE DIR_CrtTimeTenth; WORD DIR_CrtTime; WORD DIR_CrtDate; WORD DIR_LstAccDate; WORD DIR_FstClusHI; WORD DIR_WrtTime; WORD DIR_WrtDate; WORD DIR_FstClusLO; DWORD DIR_FileSize;&#125; __attribute__ ((packed)) DIR_ENTRY; find_root函数的基本思路为遍历根目录下的每一个表项，将该表项的内容填充到Dir结构体中，判断DIR_Name是否为0(未分配)或0xe5(已删除)，若是则退出返回1，表明未找到。若不是则将当前传入路径与DIR_Name进行比较，若相等，则根据pathDepth判断是否还要调用find_subdir进一步查找表项。 6.TODO 61234567891011121314151617181920212223242526272829303132333435363738394041/** TODO: * 从子目录开始查找path对应的文件或目录，找到返回0，没找到返回1，并将Dir填充为查找到的对应目录项 * * Hint1: 在find_subdir入口处，Dir应该是要查找的这一级目录的表项，需要根据其中的簇号，读取这级目录对应的扇区数据 * Hint2: 目录的大小是未知的，可能跨越多个扇区或跨越多个簇；当查找到某表项以0x00开头就可以停止查找 * Hint3: 需要查找名字为paths[curDepth]的文件或目录，同样需要根据pathDepth判断是否继续调用find_subdir函数**/int find_subdir(FAT16 *fat16_ins, DIR_ENTRY *Dir, char **paths, int pathDepth, int curDepth)&#123; int ii,i, j,flag,m; int DirSecCnt = 1; BYTE* p; BYTE buffer[BYTES_PER_SECTOR]; WORD ClusterN, FatClusEntryVal, FirstSectorofCluster; ClusterN=Dir-&gt;DIR_FstClusLO;//对于FAT16，簇号存储在低16位中 FirstSectorofCluster = ((ClusterN - 2) * fat16_ins-&gt;Bpb.BPB_SecPerClus) + fat16_ins-&gt;FirstDataSector;//获得第一个簇号的扇区号 while(ClusterN&gt;=0x0002 &amp;&amp; ClusterN&lt;=0xFFEF)&#123; for(ii=0;ii&lt;fat16_ins-&gt;Bpb.BPB_SecPerClus;ii++)&#123;//外层以每一簇的扇区个数为界限进行循环 sector_read(fat16_ins-&gt;fd, FirstSectorofCluster+ii, buffer); for (i = 0; i &lt; BYTES_PER_SECTOR/BYTES_PER_DIR; i++)&#123; //内存以每个扇区中的FAT表项数进行循环 p=&amp;buffer[i*BYTES_PER_DIR]; *Dir=*(DIR_ENTRY*)p; if(Dir-&gt;DIR_Name[0]==0x00 || Dir-&gt;DIR_Name[0]==0xe5)&#123; break; break; &#125; else if(!strncmp(paths[curDepth],Dir-&gt;DIR_Name,11)) if(curDepth+1&lt;pathDepth) return find_subdir(fat16_ins, Dir, paths, pathDepth, curDepth+1); else return 0; &#125; &#125; FatClusEntryVal = fat_entry_by_cluster(fat16_ins, ClusterN);ClusterN=FatClusEntryVal;FirstSectorofCluster = ((ClusterN - 2) * fat16_ins-&gt;Bpb.BPB_SecPerClus) + fat16_ins-&gt;FirstDataSector;//获得下一个簇的第一个扇区号 &#125; return 1; &#125; 说明：该函数是通过簇号在数据区中寻找子目录的表项，先通过已获得的根目录的表项得到首簇号，然后得到该簇号所对应的第一个扇区号。循环时，外层循环次数为每一簇对应的扇区数，内层循环次数为每个扇区对应的表项数，内层循环结束后，要判断下一个簇的簇号及其对应的第一个扇区号。具体查找过程与find_root的过程类似。 7.TODO 7 &amp; TODO 81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586int fat16_readdir(const char *path, void *buffer, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi)&#123; FAT16 *Vol; BYTE sector_buffer[BYTES_PER_SECTOR]; int RootDirCnt = 1, DirSecCnt = 1, i; struct fuse_context *context; context = fuse_get_context(); Vol = (FAT16 *) context-&gt;private_data; sector_read(Vol-&gt;fd, Vol-&gt;FirstRootDirSecNum, sector_buffer); if (strcmp(path, \"/\") == 0) &#123; DIR_ENTRY Root; /** TODO: * 将root directory下的文件或目录通过filler填充到buffer中 * 注意不需要遍历子目录 **/ for (i = 1; i &lt;= Vol-&gt;Bpb.BPB_RootEntCnt; i++) &#123; memcpy(&amp;Root, &amp;sector_buffer[((i - 1) * BYTES_PER_DIR) % BYTES_PER_SECTOR], BYTES_PER_DIR);​ ​ if (Root.DIR_Name[0] == 0x00 || Root.DIR_Name[0]==0xe5) &#123;​ return 0;​ &#125;​ if ((Root.DIR_Attr == ATTR_ARCHIVE || Root.DIR_Attr == ATTR_DIRECTORY) &amp;&amp; Root.DIR_Name[0]!=0xE5) &#123; const char *filename = (const char *) path_decode(Root.DIR_Name); filler(buffer, filename, NULL, 0); &#125; if (i % 16 == 0 &amp;&amp; i != Vol-&gt;Bpb.BPB_RootEntCnt) &#123; sector_read(Vol-&gt;fd, Vol-&gt;FirstRootDirSecNum + RootDirCnt, sector_buffer); RootDirCnt++; &#125; &#125; &#125; else &#123; DIR_ENTRY Dir; /** TODO: * 通过find_root获取path对应的目录的目录项， * 然后访问该目录，将其下的文件或目录通过filler填充到buffer中， * 同样注意不需要遍历子目录 * Hint: 需要考虑目录大小，可能跨扇区，跨簇 **/ find_root(Vol, &amp;Dir, path); WORD ClusterN = Dir.DIR_FstClusLO; WORD FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN); WORD FirstSectorofCluster = ((ClusterN - 2) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector; sector_read(Vol-&gt;fd, FirstSectorofCluster, sector_buffer); for (i = 1; Dir.DIR_Name[0] != 0x00 &amp;&amp; Dir.DIR_Name[0]!=0xe5 ; i++) &#123; if(ClusterN&lt;0x0002 || ClusterN&gt;0xFFEF) break; memcpy(&amp;Dir, &amp;sector_buffer[((i - 1) * BYTES_PER_DIR) % BYTES_PER_SECTOR], BYTES_PER_DIR); if ((Dir.DIR_Attr == ATTR_ARCHIVE || Dir.DIR_Attr == ATTR_DIRECTORY) &amp;&amp; Dir.DIR_Name[0]!=0xE5) &#123; const char *filename = (const char *) path_decode(Dir.DIR_Name); filler(buffer, filename, NULL, 0); &#125; if (i % 16 == 0) &#123; //一个扇区的表项遍历结束 if (DirSecCnt &lt; Vol-&gt;Bpb.BPB_SecPerClus) &#123; sector_read(Vol-&gt;fd, FirstSectorofCluster + DirSecCnt, sector_buffer);//读取该簇的下一个扇区 DirSecCnt++; &#125; else &#123;//否则读取下一个簇的第一个扇区号 if (FatClusEntryVal == 0xffff) &#123; return 0; &#125; ClusterN = FatClusEntryVal; FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN); FirstSectorofCluster = ((ClusterN - 2) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector; sector_read(Vol-&gt;fd, FirstSectorofCluster, sector_buffer); i = 0; DirSecCnt = 1; &#125; &#125; &#125; &#125; return 0;&#125; 说明：fat16_readdir函数用来读取相应目录所对应的文件内容，其具体操作过程分为两步： 当传入路径为’/‘时进行单独处理，由于’/‘代表根目录，所以当传入路径为’/‘时，通过遍历根目录中的每一个表项将根目录下的所有内容全部通过filler填充到buffer中，每当一个扇区中的表项遍历结束需要读取下一个扇区； 当传入路径为其它时，先调用find_root函数来获得该路径所对应的表项，然后到数据区取数据，具体的寻找过程为先获得首簇号的第一个扇区号，然后对该扇区中的每个表项进行遍历，通过filler读入到buffer中，若该扇区中的表项遍历结束判断该簇中的扇区是否遍历结束，若是则获取下一簇，否则继续读取该簇的下一个扇区。 由于文件可操作的属性不同，如图： 只有文件为子目录或存档时方可进行读取，且为了避免将已删除的文件读入，需判断DIR_Name不是0xe5。 8.TODO 9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** TODO: * 从path对应的文件的offset字节处开始读取size字节的数据到buffer中，并返回实际读取的字节数 * * Hint: 文件大小属性是Dir.DIR_FileSize；当offset超过文件大小时，应该返回0**/int fat16_read(const char *path, char *buffer, size_t size, off_t offset, struct fuse_file_info *fi)&#123; int i, j; BYTE *sector_buffer = malloc((size + offset) * sizeof(BYTE));//开辟一个大小为size+offset的空间 FAT16 *Vol; struct fuse_context *context; context = fuse_get_context(); Vol = (FAT16 *) context-&gt;private_data; DIR_ENTRY Dir; find_root(Vol, &amp;Dir, path); WORD ClusterN = Dir.DIR_FstClusLO; WORD FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN); WORD FirstSectorofCluster = ((ClusterN - 2) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector; for (i = 0, j = 0; i &lt; size + offset; i += BYTES_PER_SECTOR, j++) &#123; sector_read(Vol-&gt;fd, FirstSectorofCluster + j, sector_buffer + i);//读取每个扇区内容 if ((j + 1) % Vol-&gt;Bpb.BPB_SecPerClus == 0) &#123;//获取下一个簇的簇号及其对应第一个扇区号 ClusterN = FatClusEntryVal; if (FatClusEntryVal == 0xffff) &#123; break;//若读到末尾处时直接跳出循环 &#125; FatClusEntryVal = fat_entry_by_cluster(Vol, ClusterN); FirstSectorofCluster = ((ClusterN - 2) * Vol-&gt;Bpb.BPB_SecPerClus) + Vol-&gt;FirstDataSector; j = -1;//j++后变为0 &#125; &#125; if (offset &lt; Dir.DIR_FileSize) &#123;//读取offset偏移处的内容 memcpy(buffer, sector_buffer + offset, size); &#125; else &#123; size = 0;//否则size为0 &#125; free(sector_buffer); return size;&#125; 说明：该函数的功能为：从path对应的文件的offset字节处开始读取size字节的数据到buffer中，并返回实际读取的字节数。故开辟一个大小为size+offset的空间，读取每个扇区内容，当该簇结束且还未到达offset处时，继续获取下一个簇的簇号及其对应第一个扇区号，最后当offset小于文件大小时，从offset处读入size大小的数据，并返回字节数，否则返回字节数为0。","comments":true,"tags":[{"name":"FAT","slug":"FAT","permalink":"http://fentuoli.github.io/tags/FAT/"}]},{"title":"DOM笔记","date":"2020-05-05T05:43:36.000Z","path":"2020/05/05/DOM笔记/","text":"DOM：documentDOM节点 子节点：oUl.childNodes，只算第一层属性： length nodeType==3 -&gt;文本节点==1 -&gt;元素节点 children：只包括元素，不包括文本 父节点：oUl.parentNode 用来定位的父节点：offsetParent 首尾子节点：firstChild/firstElementChild/lastChild/lastElementChild 兄弟节点：nextSibling/nextElementSilbing/previousSibling/previousElementSibling 设置属性 getAttribute(名称) setAttribute(名称，值) removeAttribute(名称) 用className选择元素! 创建、插入、删除元素 创建：12oLi&#x3D;document.createElement(&quot;li&quot;);oUl.appendChild(oLi)&#x2F;&#x2F;父级.appendChild(oLi) 插入元素：1父级.insertBefore(名称，原有节点) 删除元素：1父级.removeChild(子节点) 文档碎片提高DOM操作性能document.creatDocumentFragment(); 表格应用 getElementsByTagName(‘tbody’)=tBodies getElementsByTagName(‘tr’)=rows getElementsByTagName(‘td’)=cells tHead，tFoot 表格添加 表格删除 模糊大小写：toLowerCase()：将大写转为小写 模糊搜索：search()方法，返回子串出现位置 多关键词搜索：str.split(‘ ‘)，将字符串切分成数组，每个分别查找一次","comments":true,"tags":[{"name":"dom","slug":"dom","permalink":"http://fentuoli.github.io/tags/dom/"}]},{"title":"Javascript笔记","date":"2020-05-05T05:36:13.000Z","path":"2020/05/05/Javascript笔记/","text":"本篇文章是我自学网易云课堂：智能社:JavaScript-从入门到精通后写的学习笔记，有需要的朋友可自行搜索！PS：本课程是我找到的所有讲解javascript最明白易懂的课程 Javascript功能交互、修改样式tip：className的使用（控制class)；JS允许连等 组成 ECMAScript(解释器)：翻译 DOM：document object model，操作HTML的能力 BOM：browser object model 变量类型 number string boolean undefined object function 一个变量应该只存放一种类型的数据 变量转换显示类型转换： parseInt：把字符串转成整数 parseFloat：把字符串转成小数 NaN和NaN不相等(用isNaN判断) 隐式类型转换： ==：先转换类型，然后比较 ===：不转换类型，直接比 !=和!==：同上 “+”功能： 字符串连接 数字相加 “-”功能：数字相减 变量作用域和闭包 作用域：局部、全局变量 闭包：子函数可以使用父函数的局部变量 程序流程控制 判断：if、switch、?:(三目运算符)，用法：条件?语句1:语句2，替换if-else 循环：while、for 跳出：break、continue 真：true、非零数字、非空字符串、非空对象 假：false、数字零、空字符串、空对象、undefined 字典循环for(var i in json) 数组基础 定义：var arr=[1,2,3]；arr=new Array(1,2,3) 添加：arr.push(4) 删除：arr.pop() 从头部删除：arr.shift() 从头部添加：arr.unshift() 删除：arr.splice(起点，长度) 插入：arr.splice(起点，长度，元素…) 连接：a.concat(b) 把数组变为字符串：arr.join(‘-‘)（用’-‘连接数组中的元素） 字符串 排序：arr.sort() 数字排序：arr.sort(function (n1,n2){return n1-n2;} 函数 函数传参：参数就是占位符 函数参数可变：arguments(arguments.length) 操作属性的方法：a.value/a[‘value’] 提取行间事件 function 名字() {} button.onclick=function() 将script代码写在head中时有可能出错，用window.onload=function( ){};来实现（先加载后执行该段代码） 元素.style.属性=xxx是修改行间样式，之后再修改className不会有效果 提取非行间样式：oDiv.currentStyle.属性、getComputedSytle(oDiv,false).属性 获取一组元素getElementsByTagName获取的是数组 选项卡 this：当前发生事件的元素 可以通过js给标签添加新的属性 innerHTML 标签中显示的文字，可以按html的格式来写 定时器 开启定时器 间隔型：setInterval(事件，时间) 延时性：setTimeout(事件，时间) 关闭定时器 clearInterval() clearTimeout() Date对象：var oDate=new Date(); oDate.getHours() oDate.getMinutes() oDate.getSeconds() oDate.getFullYear() oDate.getMonth()+1 oDate.getDate() oDate.getDay()（返回星期，0为周日…） 由于兼容性，为获取字符串的某一位，要将str[0]改为str.charAt(0) 延时提示框 鼠标移入：onmouseover 鼠标移出：onmouseout 用setTimeout控制延时消失 当鼠标移入提示框时，关闭定时器 当鼠标移出提示框时，提示框消失 无缝滚动 offsetLeft/offsetTop获取物体边距 offsetHeight/offsetWidth 改变滚动方向","comments":true,"tags":[{"name":"javascript","slug":"javascript","permalink":"http://fentuoli.github.io/tags/javascript/"}]},{"title":"HTML笔记","date":"2020-05-05T04:50:47.000Z","path":"2020/05/05/HTML笔记/","text":"本篇文章是我自学网易云课堂：撩课-玩转H5大前端-HTML+CSS后写的学习笔记，有需要的朋友可自行搜索！ HTML web标准：结构(html)、表现(css)、行为(js) HTML：超文本标记语言 HTML文档结构：&lt;html&gt;、&lt;head&gt;(外部资源引用等)、&lt;body&gt;(网页主体) &lt;head&gt; &lt;title&gt;展示网页标题、&lt;meta&gt;元标签：描述HTML网页文档的属性(提供文档字符集、使用语言、作者等描述信息) 闭合标签中填写内容、单标签中填写属性 样式/节 123&lt;style&gt;p&#123;&#125;&lt;/style&gt;：定义文本的标签样式信息 &lt;body&gt; 标题标签：以h开头，h1到h6，&lt;br&gt;进行分割 段落标签：&lt;p&gt;标签 图像标签： &lt;img src=”url” alt=”图片描述”&gt; 包括一些可选属性 换行标签：&lt;br&gt; 表单标签： &lt;input type=”类型” value=”默认文字” placeholder=”提示文字”&gt; 类型有text、password、date、color、file(文件上传功能)、checkbox(复选框)、radio(单选框)等 超级链接a标签： &lt;a href=””&gt;文字&lt;/a&gt; 锚点跳转：&lt;a href=”#one”&gt;&lt;/a&gt; &lt;p id=”one”&gt;段落&lt;/p&gt; 列表标签： 123&lt;ul type=\"\"&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;/ul&gt; 123&lt;ol&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;/ol&gt; 1234&lt;dl&gt; &lt;dt&gt;标题&lt;/dt&gt; &lt;dd&gt;定义列表中条目的定义部分&lt;/dd&gt; &lt;/dl&gt; 表单标签： 123456789&lt;form action=\"服务器url\"&gt; &lt;lable&gt;用户名：&lt;/lable&gt; &lt;input type=\"text\"&gt; &lt;textarea rows=\"10\" cols=\"10\"&gt;多行文本输入空间&lt;/textarea&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;select name=\"sex\"&gt; &lt;option value=\"男&gt;男&lt;/option&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 节标签： &lt;div&gt;内容&lt;/div&gt;(对文档结构进行划分，纵向) &lt;span&gt;内容&lt;span&gt;(对页面进行布局，横向) 语义化标签(用于语义化替换&lt;div&gt;、媒介标签(video、audio)、表单控件标签、绘图标签) 标签使用补充 标签之间的关系 祖先元素 后代元素 父元素、子元素、兄弟元素 设置浏览器标签图标： favicon.ico 在线制作：www.faviconico.org 放在根目录 meta标签属性补充：定义网站关键字和网站描述 CSS 作用：美化网页 HTML用来构建网页整体布局 一重或多重声明 CSS样式： 行内样式：作用于一行 页内样式：作用于整个页面 外部样式：新建一个stylesheet文件，在原文件&lt;head&gt;中引入：&lt;link rel=”stylesheet” href=”路径”&gt; CSS选择器 通用选择器：*（优先级最低） 标签选择器 类选择器：.类名{ }(类名在标签中用class定义，如：&lt;div class=”test”&gt;，一个标签可以有多个类名) id选择器：为标有特定id的HTML元素设置样式，格式：#id名{ }，id在标签中用id定义，id只能用于一个标签 复合选择器：如div.test1{ }或div#main 群组选择器(并列选择器)，如：div,span,.test1{ }，同时作用于多个标签 后代选择器：格式：祖先元素 后代元素 后代元素{ } 直接后代选择器：父元素&gt;子元素{ } 兄弟选择器：查找后边一个兄弟元素：兄弟元素+兄弟元素{}；查找后边所有兄弟元素：兄弟元素~兄弟元素{ } 属性选择器：选择有特殊属性的标签，格式：标签[属性][属性]{ } 伪类和伪元素 否定伪类 选择器的优先级：选择器的权值：* ：0；类：10；属性：10；伪类/伪元素：10；id：100；复合：相加；important：1000；(!important) 权值大的优先级高，权值相同后定义的优先级高 标签元素划分： 块元素：ul,li,form,hr,p,h1-h6,div（自己单独占一行，就像一个段落，可以改变高度和宽度） 内联（行内）元素：不会自己独占一行，会一直往后排，宽度、高度、内边距都不可改变，常见的有：a,big,br,em,img,input,label,select等 内联-块级元素：select,textarea,button,input,在一行显示，可以设置宽度和高度 块元素与行内元素互换：块-&gt;行内：display:inline；行内-&gt;块：display:block；行内块级-&gt;块：display:block 块属性：（见讲义） 盒子模型：padding,border…(盒子圆角：border-radius) 标准盒子模型 IE盒子模型 浮动：float 标签居中：水平/垂直居中 行内水平：text-align:center； 块级元素水平居中：margin:0 auto； 行内标签垂直居中：line-height和外部保持一致 行内元素水平对齐：vertical-align:middle css常见属性： visibility:visible/hidden（会占位） cursor:pointer/mov/help… color font text-decoration:none(去除下划线) text-indent:2% 首行缩进 text-align 对齐 overflow 控制文字溢出 页面布局 定位(position)： static relative absolute(相对于父标签) fixed relative：以自身为参照，层级提高一级 absolute：相对于距离它最近的开启了定位的祖先元素进行定位，否则相对于浏览器窗口进行定位，提高一个层级，内联变块 fixed：相对于浏览器窗口进行定位，不会随滚动条滚动 标签层级：定位元素&gt;浮动元素&gt;文档流中的元素 元素开启定位后，可通过z-index来设置元素的层级 z-index越高元素越优先显示 父元素永远不会覆盖子元素 标签设置圆角：border-radius ​","comments":true,"tags":[{"name":"HTML","slug":"HTML","permalink":"http://fentuoli.github.io/tags/HTML/"}]},{"title":"编译原理之文法分析","date":"2020-05-05T00:37:54.000Z","path":"2020/05/05/编译原理之文法分析/","text":"自顶向下：采用回溯 递归向下：对每个非终结符进行分治讨论 LL(1）分析算法： 从左向右，最左推导，采用一个前看符号 LL(1)分析表： 弹出非终结符后应该压入哪条产生式的右部 FIRST集计算规则：1. N-&gt;a 并入 N-&gt;M1M2M3… M1的FIRST并入N的FIRST 直至第一个推不出空的非终结符的FIRST并入N的FIRST 构造LL(1)分析表，将FIRST推广到任意串上 每个表项只有一个，称为LL(1)文法 无冲突要求两条FIRST_S的交集为空 FOLLOW集用来判断当一个非终结符可以推出空时，什么字符（产生式规则）可以跟在它后面 FOLLOW计算规则： 从一条产生式的最后一个字符开始进行判断 采用不动点算法，直至不发生改变 计算FIRST_S:若产生式右部均为NULLABLE，则将左部非终结符的FOLLOW也加进去 LL(1)冲突解决：1. 消除左递归 提取左公因子LR(0)分析算法：自底向上 判断能否进行规约 最右推导的逆过程 将栈上的右部弹掉，压入左部 从左向右读入程序，最右推导，不用前看符号 缺点： 延迟错误发现时机，可能包含移进-规约冲突 LR(0)分析表： Sn后的n指项目序号，Rn后的n值第几条文法符号 ACTION和GOTO表 SLR分析算法： 与LR(0)区别：对于状态i上的项目X-&gt;α●，仅对y∈FOLLOW(X)添加ACTION[i,y] 优点： 减少需要规约的情况 可能去除移进规约冲突 缺点： 移进规约冲突仍可能存在 LR(1)分析算法： 与LR(0)相比：仅闭包的计算不同：对项目[X-&gt;α●Yβ,a]，添加[Y-&gt;●γ，b]到项目集，其中b∈FIRST_S(βα) 如果有移进规约冲突则不是LR(1)文法 二义性文法无法使用LR分析法 二义性文法的处理方法： 优先级 结合性 悬空else LALR分析算法： 把类似的项目集进行合并 可能带来规约规约冲突 补充： SLR(1)判断规则：方法一：画出文法的LR(0)自动机，如果没有移进–规约冲突，即shift–reduce 冲突，则该文法是SLR(1)文法 LALR(1)和LR(1)的判断规则：画出文法的LR(1)自动机，如果没有同心项且没有状态冲突，则该文法是LALR(1)文法；如果有同心项且合并同心项有状态冲突，则是LR（1）文法 证明是LL(1)文法： ：对任意两个产生式A→α|β 都有：1） First(α )∩First(β )=Φ2）若 β⇒* ε, 则First(A)∩Follow(A)=Φ 正则表达式： 不能用于配对或嵌套 表示给定结构的固定次数的重复或没有指定次数的重复","comments":true,"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://fentuoli.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"写给自己的博客","date":"2020-04-30T13:07:15.000Z","path":"2020/04/30/前言/","text":"创建这个博客是为了鼓励自己能阶段性地总结学过的东西，改掉学过就忘的毛病。我把自己踩过的坑，以及解决方案写上来，也希望对其他人有所帮助。 愿与君共勉！","comments":true,"tags":[{"name":"前言","slug":"前言","permalink":"http://fentuoli.github.io/tags/%E5%89%8D%E8%A8%80/"}]}]